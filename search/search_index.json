{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"memegen.link An API to programatically generate memes based solely on requested URLs. Read the latest documentation here . Generating Images The API is stateless so URLs contain all the information necessary to generate meme images. For example, https://api.memegen.link/images/buzz/memes/memes_everywhere.png produces: Special Characters In URLs, spaces can be inserted using underscores or dashes: underscore ( _ ) \u2192 space ( ) dash ( - ) \u2192 space ( ) 2 underscores ( __ ) \u2192 underscore ( _ ) 2 dashes ( -- ) \u2192 dash ( - ) Reserved URL characters can be include using escape patterns: tilde + Q ( ~q ) \u2192 question mark ( ? ) tilde + P ( ~p ) \u2192 percentage ( % ) tilde + H ( ~h ) \u2192 hashtag/pound ( # ) tilde + S ( ~s ) \u2192 slash ( / ) tilde + B ( ~b ) \u2192 backslash ( \\ ) 2 single quotes ( '' ) \u2192 double quote ( \" ) For example, https://api.memegen.link/images/doge/~hspecial_characters~q/underscore__-dash--.png produces: Alternate Styles Some memes come in multiple forms, which can be selected via ?style=<style> . For example, these are two styles provided by the https://api.memegen.link/templates/ds template: /images/ds.png /images/ds.png?style=maga Custom Backgrounds You can also use your own image URL as the background. For example, https://api.memegen.link/images/custom/_/my_background.png?background=http://www.gstatic.com/webp/gallery/1.png produces: Image Sizing Images can be scaled to a specific width via ?width=<int> or a specific height via ?height=<int> . If both parameters are provided ( ?width=<int>&height=<int> ), the image will be padded to the exact dimensions. For example, https://api.memegen.link/images/both/width_or_height/why_not_both~q.png?height=350&width=600 produces: Clients can also request .jpg instead of .png for smaller files. Live Previews If your client is going to show live previews of a custom meme, please use the /images/preview.jpg endpoint, which accepts URL-encoded parameters and returns smaller images to minimize bandwidth. Both template keys and URLs are supported: https://api.memegen.link/images/preview.jpg?template=fry&line[]=first&line[]=second https://api.memegen.link/images/preview.jpg?template=https://api.memegen.link/images/fry.png&line[]=first&line[]=second API Documentation The full interactive API documentation is available here: https://api.memegen.link/docs/ Sample Clients Here are some sample clients to explore: Platforms Link Source Slack --- Python: nicolewhite/slack-meme Slack --- Go: CptSpaceToaster/slackbot Slack http://www.memetizer.com --- Hain --- JavaScript: Metrakit/hain-plugin-meme Web --- Clojure: jasich/mighty-fine-memes Web, Slack https://memecomplete.com --- Discord --- JavaScript: parshsee/discordbot Additional clients can be found by searching for code examples on GitHub .","title":"Home"},{"location":"#memegenlink","text":"An API to programatically generate memes based solely on requested URLs. Read the latest documentation here .","title":"memegen.link"},{"location":"#generating-images","text":"The API is stateless so URLs contain all the information necessary to generate meme images. For example, https://api.memegen.link/images/buzz/memes/memes_everywhere.png produces:","title":"Generating Images"},{"location":"#special-characters","text":"In URLs, spaces can be inserted using underscores or dashes: underscore ( _ ) \u2192 space ( ) dash ( - ) \u2192 space ( ) 2 underscores ( __ ) \u2192 underscore ( _ ) 2 dashes ( -- ) \u2192 dash ( - ) Reserved URL characters can be include using escape patterns: tilde + Q ( ~q ) \u2192 question mark ( ? ) tilde + P ( ~p ) \u2192 percentage ( % ) tilde + H ( ~h ) \u2192 hashtag/pound ( # ) tilde + S ( ~s ) \u2192 slash ( / ) tilde + B ( ~b ) \u2192 backslash ( \\ ) 2 single quotes ( '' ) \u2192 double quote ( \" ) For example, https://api.memegen.link/images/doge/~hspecial_characters~q/underscore__-dash--.png produces:","title":"Special Characters"},{"location":"#alternate-styles","text":"Some memes come in multiple forms, which can be selected via ?style=<style> . For example, these are two styles provided by the https://api.memegen.link/templates/ds template: /images/ds.png /images/ds.png?style=maga","title":"Alternate Styles"},{"location":"#custom-backgrounds","text":"You can also use your own image URL as the background. For example, https://api.memegen.link/images/custom/_/my_background.png?background=http://www.gstatic.com/webp/gallery/1.png produces:","title":"Custom Backgrounds"},{"location":"#image-sizing","text":"Images can be scaled to a specific width via ?width=<int> or a specific height via ?height=<int> . If both parameters are provided ( ?width=<int>&height=<int> ), the image will be padded to the exact dimensions. For example, https://api.memegen.link/images/both/width_or_height/why_not_both~q.png?height=350&width=600 produces: Clients can also request .jpg instead of .png for smaller files.","title":"Image Sizing"},{"location":"#live-previews","text":"If your client is going to show live previews of a custom meme, please use the /images/preview.jpg endpoint, which accepts URL-encoded parameters and returns smaller images to minimize bandwidth. Both template keys and URLs are supported: https://api.memegen.link/images/preview.jpg?template=fry&line[]=first&line[]=second https://api.memegen.link/images/preview.jpg?template=https://api.memegen.link/images/fry.png&line[]=first&line[]=second","title":"Live Previews"},{"location":"#api-documentation","text":"The full interactive API documentation is available here: https://api.memegen.link/docs/","title":"API Documentation"},{"location":"#sample-clients","text":"Here are some sample clients to explore: Platforms Link Source Slack --- Python: nicolewhite/slack-meme Slack --- Go: CptSpaceToaster/slackbot Slack http://www.memetizer.com --- Hain --- JavaScript: Metrakit/hain-plugin-meme Web --- Clojure: jasich/mighty-fine-memes Web, Slack https://memecomplete.com --- Discord --- JavaScript: parshsee/discordbot Additional clients can be found by searching for code examples on GitHub .","title":"Sample Clients"},{"location":"CHANGELOG/","text":"Revision History 6.2 Added /images/preview.jpg route for quicker responses when clients want to show live previews of a custom meme. 6.1 Added extension parameter to specify image format when using POST endpoints. 6.0 Initial release of the API rewrite using Sanic. 5.x Prior history: https://github.com/jacebrowning/memegen-flask/blob/main/CHANGELOG.md","title":"Changelog"},{"location":"CHANGELOG/#revision-history","text":"","title":"Revision History"},{"location":"CHANGELOG/#62","text":"Added /images/preview.jpg route for quicker responses when clients want to show live previews of a custom meme.","title":"6.2"},{"location":"CHANGELOG/#61","text":"Added extension parameter to specify image format when using POST endpoints.","title":"6.1"},{"location":"CHANGELOG/#60","text":"Initial release of the API rewrite using Sanic.","title":"6.0"},{"location":"CHANGELOG/#5x","text":"Prior history: https://github.com/jacebrowning/memegen-flask/blob/main/CHANGELOG.md","title":"5.x"},{"location":"CONTRIBUTING/","text":"Contributing Setup Requirements Make: macOS: $ xcode-select --install Linux: https://www.gnu.org/software/make Windows: https://mingw.org/download/installer Python: $ pyenv install Poetry: https://poetry.eustace.io/docs/#installation To confirm these system dependencies are configured correctly: $ make doctor Installation Install project dependencies into a virtual environment: $ make install Local Development To start the API server: $ make run Adding a Template To add a new meme template: Visit /images/<my_new_template_key> Add a default.png (or JPG) background image in templates directory Update config.yml in the templates directory Refresh /images/<my_new_template_key> to see the sample meme Continuous Integration Manual Run the tests: $ make test Run static analysis: $ make check Automatic Keep all of the above tasks running on change: $ make watch","title":"Contributing"},{"location":"CONTRIBUTING/#contributing","text":"","title":"Contributing"},{"location":"CONTRIBUTING/#setup","text":"","title":"Setup"},{"location":"CONTRIBUTING/#requirements","text":"Make: macOS: $ xcode-select --install Linux: https://www.gnu.org/software/make Windows: https://mingw.org/download/installer Python: $ pyenv install Poetry: https://poetry.eustace.io/docs/#installation To confirm these system dependencies are configured correctly: $ make doctor","title":"Requirements"},{"location":"CONTRIBUTING/#installation","text":"Install project dependencies into a virtual environment: $ make install","title":"Installation"},{"location":"CONTRIBUTING/#local-development","text":"To start the API server: $ make run","title":"Local Development"},{"location":"CONTRIBUTING/#adding-a-template","text":"To add a new meme template: Visit /images/<my_new_template_key> Add a default.png (or JPG) background image in templates directory Update config.yml in the templates directory Refresh /images/<my_new_template_key> to see the sample meme","title":"Adding a Template"},{"location":"CONTRIBUTING/#continuous-integration","text":"","title":"Continuous Integration"},{"location":"CONTRIBUTING/#manual","text":"Run the tests: $ make test Run static analysis: $ make check","title":"Manual"},{"location":"CONTRIBUTING/#automatic","text":"Keep all of the above tasks running on change: $ make watch","title":"Automatic"},{"location":"reference/app/","text":"Module app Sub-modules app.api app.errors app.helpers app.models app.settings app.tests app.types app.utils app.views","title":"Index"},{"location":"reference/app/#module-app","text":"","title":"Module app"},{"location":"reference/app/#sub-modules","text":"app.api app.errors app.helpers app.models app.settings app.tests app.types app.utils app.views","title":"Sub-modules"},{"location":"reference/app/errors/","text":"Module app.errors View Source import bugsnag from aiohttp.client_exceptions import ClientPayloadError from sanic.exceptions import MethodNotSupported , NotFound from sanic.handlers import ErrorHandler from . import settings IGNORED_EXCEPTIONS = ( NotFound , MethodNotSupported , ClientPayloadError ) bugsnag . configure ( api_key = settings . BUGSNAG_API_KEY , project_root = \"/app\" , release_stage = settings . RELEASE_STAGE , ) class BugsnagErrorHandler ( ErrorHandler ): # pragma: no cover def default ( self , request , exception ): if self . _should_report ( exception ): bugsnag . notify ( exception , meta_data = { \"request\" : request . url }) return super () . default ( request , exception ) def _should_report ( self , exception ) -> bool : if not settings . BUGSNAG_API_KEY : return False if isinstance ( exception , IGNORED_EXCEPTIONS ): return False return True Variables IGNORED_EXCEPTIONS Classes BugsnagErrorHandler class BugsnagErrorHandler ( ) Provide :class: sanic.app.Sanic application with a mechanism to handle and process any and all uncaught exceptions in a way the application developer will set fit. This error handling framework is built into the core that can be extended by the developers to perform a wide range of tasks from recording the error stats to reporting them to an external service that can be used for realtime alerting system. View Source class BugsnagErrorHandler ( ErrorHandler ): # pragma: no cover def default ( self , request , exception ): if self . _should_report ( exception ): bugsnag . notify ( exception , meta_data ={ \"request\" : request . url }) return super (). default ( request , exception ) def _should_report ( self , exception ) -> bool: if not settings . BUGSNAG_API_KEY: return False if isinstance ( exception , IGNORED_EXCEPTIONS ): return False return True Ancestors (in MRO) sanic.handlers.ErrorHandler Class variables cached_handlers handlers Methods add def add ( self , exception , handler ) Add a new exception handler to an already existing handler object. :param exception: Type of exception that need to be handled :param handler: Reference to the method that will handle the exception :type exception: :class: sanic.exceptions.SanicException or :class: Exception :type handler: function :return: None View Source def add ( self , exception , handler ) : \" \"\" Add a new exception handler to an already existing handler object. :param exception: Type of exception that need to be handled :param handler: Reference to the method that will handle the exception :type exception: :class:`sanic.exceptions.SanicException` or :class:`Exception` :type handler: ``function`` :return: None \"\" \" self . handlers . append (( exception , handler )) default def default ( self , request , exception ) Provide a default behavior for the objects of :class: ErrorHandler . If a developer chooses to extent the :class: ErrorHandler they can provide a custom implementation for this method to behave in a way they see fit. :param request: Incoming request :param exception: Exception object :type request: :class: sanic.request.Request :type exception: :class: sanic.exceptions.SanicException or :class: Exception :return: View Source def default ( self , request , exception ): if self . _should_report ( exception ): bugsnag . notify ( exception , meta_data = { \"request\" : request . url } ) return super (). default ( request , exception ) log def log ( self , message , level = 'error' ) Deprecated, do not use. View Source def log ( self , message , level = \"error\" ): \"\"\" Deprecated, do not use. \"\"\" lookup def lookup ( self , exception ) Lookup the existing instance of :class: ErrorHandler and fetch the registered handler for a specific type of exception. This method leverages a dict lookup to speedup the retrieval process. :param exception: Type of exception :type exception: :class: sanic.exceptions.SanicException or :class: Exception :return: Registered function if found None otherwise View Source def lookup ( self , exception ) : \" \"\" Lookup the existing instance of :class:`ErrorHandler` and fetch the registered handler for a specific type of exception. This method leverages a dict lookup to speedup the retrieval process. :param exception: Type of exception :type exception: :class:`sanic.exceptions.SanicException` or :class:`Exception` :return: Registered function if found ``None`` otherwise \"\" \" handler = self . cached_handlers . get ( type ( exception ), self . _missing ) if handler is self . _missing : for exception_class , handler in self . handlers : if isinstance ( exception , exception_class ) : self . cached_handlers [ type ( exception ) ] = handler return handler self . cached_handlers [ type ( exception ) ] = None handler = None return handler response def response ( self , request , exception ) Fetches and executes an exception handler and returns a response object :param request: Instance of :class: sanic.request.Request :param exception: Exception to handle :type request: :class: sanic.request.Request :type exception: :class: sanic.exceptions.SanicException or :class: Exception :return: Wrap the return value obtained from :func: default or registered handler for that type of exception. View Source def response ( self , request , exception ) : \" \"\" Fetches and executes an exception handler and returns a response object :param request: Instance of :class:`sanic.request.Request` :param exception: Exception to handle :type request: :class:`sanic.request.Request` :type exception: :class:`sanic.exceptions.SanicException` or :class:`Exception` :return: Wrap the return value obtained from :func:`default` or registered handler for that type of exception. \"\" \" handler = self . lookup ( exception ) response = None try : if handler : response = handler ( request , exception ) if response is None : response = self . default ( request , exception ) except Exception : self . log ( format_exc ()) try : url = repr ( request . url ) except AttributeError : url = \"unknown\" response_message = ( \"Exception raised in exception handler \" '\"%s\" for uri: %s' ) logger . exception ( response_message , handler . __name__ , url ) if self . debug : return text ( response_message % ( handler . __name__ , url ), 500 ) else : return text ( \"An error occurred while handling an error\" , 500 ) return response","title":"Errors"},{"location":"reference/app/errors/#module-apperrors","text":"View Source import bugsnag from aiohttp.client_exceptions import ClientPayloadError from sanic.exceptions import MethodNotSupported , NotFound from sanic.handlers import ErrorHandler from . import settings IGNORED_EXCEPTIONS = ( NotFound , MethodNotSupported , ClientPayloadError ) bugsnag . configure ( api_key = settings . BUGSNAG_API_KEY , project_root = \"/app\" , release_stage = settings . RELEASE_STAGE , ) class BugsnagErrorHandler ( ErrorHandler ): # pragma: no cover def default ( self , request , exception ): if self . _should_report ( exception ): bugsnag . notify ( exception , meta_data = { \"request\" : request . url }) return super () . default ( request , exception ) def _should_report ( self , exception ) -> bool : if not settings . BUGSNAG_API_KEY : return False if isinstance ( exception , IGNORED_EXCEPTIONS ): return False return True","title":"Module app.errors"},{"location":"reference/app/errors/#variables","text":"IGNORED_EXCEPTIONS","title":"Variables"},{"location":"reference/app/errors/#classes","text":"","title":"Classes"},{"location":"reference/app/errors/#bugsnagerrorhandler","text":"class BugsnagErrorHandler ( ) Provide :class: sanic.app.Sanic application with a mechanism to handle and process any and all uncaught exceptions in a way the application developer will set fit. This error handling framework is built into the core that can be extended by the developers to perform a wide range of tasks from recording the error stats to reporting them to an external service that can be used for realtime alerting system. View Source class BugsnagErrorHandler ( ErrorHandler ): # pragma: no cover def default ( self , request , exception ): if self . _should_report ( exception ): bugsnag . notify ( exception , meta_data ={ \"request\" : request . url }) return super (). default ( request , exception ) def _should_report ( self , exception ) -> bool: if not settings . BUGSNAG_API_KEY: return False if isinstance ( exception , IGNORED_EXCEPTIONS ): return False return True","title":"BugsnagErrorHandler"},{"location":"reference/app/errors/#ancestors-in-mro","text":"sanic.handlers.ErrorHandler","title":"Ancestors (in MRO)"},{"location":"reference/app/errors/#class-variables","text":"cached_handlers handlers","title":"Class variables"},{"location":"reference/app/errors/#methods","text":"","title":"Methods"},{"location":"reference/app/errors/#add","text":"def add ( self , exception , handler ) Add a new exception handler to an already existing handler object. :param exception: Type of exception that need to be handled :param handler: Reference to the method that will handle the exception :type exception: :class: sanic.exceptions.SanicException or :class: Exception :type handler: function :return: None View Source def add ( self , exception , handler ) : \" \"\" Add a new exception handler to an already existing handler object. :param exception: Type of exception that need to be handled :param handler: Reference to the method that will handle the exception :type exception: :class:`sanic.exceptions.SanicException` or :class:`Exception` :type handler: ``function`` :return: None \"\" \" self . handlers . append (( exception , handler ))","title":"add"},{"location":"reference/app/errors/#default","text":"def default ( self , request , exception ) Provide a default behavior for the objects of :class: ErrorHandler . If a developer chooses to extent the :class: ErrorHandler they can provide a custom implementation for this method to behave in a way they see fit. :param request: Incoming request :param exception: Exception object :type request: :class: sanic.request.Request :type exception: :class: sanic.exceptions.SanicException or :class: Exception :return: View Source def default ( self , request , exception ): if self . _should_report ( exception ): bugsnag . notify ( exception , meta_data = { \"request\" : request . url } ) return super (). default ( request , exception )","title":"default"},{"location":"reference/app/errors/#log","text":"def log ( self , message , level = 'error' ) Deprecated, do not use. View Source def log ( self , message , level = \"error\" ): \"\"\" Deprecated, do not use. \"\"\"","title":"log"},{"location":"reference/app/errors/#lookup","text":"def lookup ( self , exception ) Lookup the existing instance of :class: ErrorHandler and fetch the registered handler for a specific type of exception. This method leverages a dict lookup to speedup the retrieval process. :param exception: Type of exception :type exception: :class: sanic.exceptions.SanicException or :class: Exception :return: Registered function if found None otherwise View Source def lookup ( self , exception ) : \" \"\" Lookup the existing instance of :class:`ErrorHandler` and fetch the registered handler for a specific type of exception. This method leverages a dict lookup to speedup the retrieval process. :param exception: Type of exception :type exception: :class:`sanic.exceptions.SanicException` or :class:`Exception` :return: Registered function if found ``None`` otherwise \"\" \" handler = self . cached_handlers . get ( type ( exception ), self . _missing ) if handler is self . _missing : for exception_class , handler in self . handlers : if isinstance ( exception , exception_class ) : self . cached_handlers [ type ( exception ) ] = handler return handler self . cached_handlers [ type ( exception ) ] = None handler = None return handler","title":"lookup"},{"location":"reference/app/errors/#response","text":"def response ( self , request , exception ) Fetches and executes an exception handler and returns a response object :param request: Instance of :class: sanic.request.Request :param exception: Exception to handle :type request: :class: sanic.request.Request :type exception: :class: sanic.exceptions.SanicException or :class: Exception :return: Wrap the return value obtained from :func: default or registered handler for that type of exception. View Source def response ( self , request , exception ) : \" \"\" Fetches and executes an exception handler and returns a response object :param request: Instance of :class:`sanic.request.Request` :param exception: Exception to handle :type request: :class:`sanic.request.Request` :type exception: :class:`sanic.exceptions.SanicException` or :class:`Exception` :return: Wrap the return value obtained from :func:`default` or registered handler for that type of exception. \"\" \" handler = self . lookup ( exception ) response = None try : if handler : response = handler ( request , exception ) if response is None : response = self . default ( request , exception ) except Exception : self . log ( format_exc ()) try : url = repr ( request . url ) except AttributeError : url = \"unknown\" response_message = ( \"Exception raised in exception handler \" '\"%s\" for uri: %s' ) logger . exception ( response_message , handler . __name__ , url ) if self . debug : return text ( response_message % ( handler . __name__ , url ), 500 ) else : return text ( \"An error occurred while handling an error\" , 500 ) return response","title":"response"},{"location":"reference/app/helpers/","text":"Module app.helpers View Source from typing import Dict , List , Tuple from urllib.parse import unquote import aiohttp from cachetools import cached from sanic.log import logger from sanic_cors import CORS from sanic_openapi import swagger_blueprint from . import api , errors , settings , utils from .models import Template def configure ( app ): app . config . API_HOST = app . config . SERVER_NAME = settings . SERVER_NAME app . config . API_BASEPATH = \"/\" app . config . API_SCHEMES = [ settings . SCHEME ] app . config . API_VERSION = \"6.2\" app . config . API_TITLE = \"Memegen API\" app . config . API_CONTACT_EMAIL = \"support@maketested.com\" app . config . API_LICENSE_NAME = \"View license\" app . config . API_LICENSE_URL = ( \"https://github.com/jacebrowning/memegen/blob/main/LICENSE.txt\" ) app . config . API_SECURITY = [{ \"ApiKeyAuth\" : []}] app . config . API_SECURITY_DEFINITIONS = { \"ApiKeyAuth\" : { \"type\" : \"apiKey\" , \"in\" : \"header\" , \"name\" : \"X-API-KEY\" } } swagger_blueprint . url_prefix = \"/docs\" app . blueprint ( swagger_blueprint ) app . blueprint ( api . images . blueprint ) app . blueprint ( api . templates . blueprint ) app . blueprint ( api . shortcuts . blueprint ) CORS ( app ) app . error_handler = errors . BugsnagErrorHandler () @cached ({}, key = lambda x : 0 if settings . DEPLOYED else x ) # type: ignore def get_valid_templates ( request ) -> List [ Dict ]: templates = Template . objects . filter ( valid = True , _exclude = \"_custom\" ) return [ t . jsonify ( request . app ) for t in templates ] @cached ({}, key = lambda x : 0 if settings . DEPLOYED else x ) # type: ignore def get_sample_images ( request ) -> List [ Tuple [ str , str ]]: return [ ( template . build_sample_url ( request . app ), template . build_self_url ( request . app )) for template in Template . objects . filter ( valid = True , _exclude = \"_custom\" ) ] def get_test_images ( request ) -> List [ str ]: return [ request . app . url_for ( f \"images.text_{settings.DEFAULT_EXT}\" , template_key = key , text_paths = utils . text . encode ( lines ), ) for key , lines in settings . TEST_IMAGES ] async def track ( request , lines ): if settings . REMOTE_TRACKING_URL : # pragma: no cover async with aiohttp . ClientSession () as session : params = dict ( text = \" \" . join ( lines ), source = \"memegen.link\" , context = unquote ( request . url ), ) response = await session . get ( settings . REMOTE_TRACKING_URL , params = params ) if response . status != 200 : try : message = await response . json () except aiohttp . client_exceptions . ContentTypeError : message = response . text logger . error ( f \"Tracker response: {message}\" ) Functions configure def configure ( app ) View Source def configure ( app ) : app . config . API_HOST = app . config . SERVER_NAME = settings . SERVER_NAME app . config . API_BASEPATH = \"/\" app . config . API_SCHEMES = [ settings.SCHEME ] app . config . API_VERSION = \"6.2\" app . config . API_TITLE = \"Memegen API\" app . config . API_CONTACT_EMAIL = \"support@maketested.com\" app . config . API_LICENSE_NAME = \"View license\" app . config . API_LICENSE_URL = ( \"https://github.com/jacebrowning/memegen/blob/main/LICENSE.txt\" ) app . config . API_SECURITY = [ {\"ApiKeyAuth\": [ ] }] app . config . API_SECURITY_DEFINITIONS = { \"ApiKeyAuth\" : { \"type\" : \"apiKey\" , \"in\" : \"header\" , \"name\" : \"X-API-KEY\" } } swagger_blueprint . url_prefix = \"/docs\" app . blueprint ( swagger_blueprint ) app . blueprint ( api . images . blueprint ) app . blueprint ( api . templates . blueprint ) app . blueprint ( api . shortcuts . blueprint ) CORS ( app ) app . error_handler = errors . BugsnagErrorHandler () get_sample_images def get_sample_images ( request ) -> List [ Tuple [ str , str ]] View Source @cached ( {} , key = lambda x : 0 if settings . DEPLOYED else x ) # type : ignore def get_sample_images ( request ) -> List [ Tuple[str, str ] ]: return [ (template.build_sample_url(request.app), template.build_self_url(request.app)) for template in Template.objects.filter(valid=True, _exclude=\"_custom\") ] get_test_images def get_test_images ( request ) -> List [ str ] View Source def get_test_images ( request ) -> List [ str ] : return [ request.app.url_for( f\"images.text_{settings.DEFAULT_EXT}\", template_key=key, text_paths=utils.text.encode(lines), ) for key, lines in settings.TEST_IMAGES ] get_valid_templates def get_valid_templates ( request ) -> List [ Dict ] View Source @cached ( {} , key = lambda x : 0 if settings . DEPLOYED else x ) # type : ignore def get_valid_templates ( request ) -> List [ Dict ] : templates = Template . objects . filter ( valid = True , _exclude = \"_custom\" ) return [ t.jsonify(request.app) for t in templates ] track def track ( request , lines ) View Source async def track ( request , lines ): if settings . REMOTE_TRACKING_URL : # pragma : no cover async with aiohttp . ClientSession () as session : params = dict ( text = \" \" . join ( lines ), source = \"memegen.link\" , context = unquote ( request . url ), ) response = await session . get ( settings . REMOTE_TRACKING_URL , params = params ) if response . status != 200 : try : message = await response . json () except aiohttp . client_exceptions . ContentTypeError : message = response . text logger . error ( f \"Tracker response: {message}\" )","title":"Helpers"},{"location":"reference/app/helpers/#module-apphelpers","text":"View Source from typing import Dict , List , Tuple from urllib.parse import unquote import aiohttp from cachetools import cached from sanic.log import logger from sanic_cors import CORS from sanic_openapi import swagger_blueprint from . import api , errors , settings , utils from .models import Template def configure ( app ): app . config . API_HOST = app . config . SERVER_NAME = settings . SERVER_NAME app . config . API_BASEPATH = \"/\" app . config . API_SCHEMES = [ settings . SCHEME ] app . config . API_VERSION = \"6.2\" app . config . API_TITLE = \"Memegen API\" app . config . API_CONTACT_EMAIL = \"support@maketested.com\" app . config . API_LICENSE_NAME = \"View license\" app . config . API_LICENSE_URL = ( \"https://github.com/jacebrowning/memegen/blob/main/LICENSE.txt\" ) app . config . API_SECURITY = [{ \"ApiKeyAuth\" : []}] app . config . API_SECURITY_DEFINITIONS = { \"ApiKeyAuth\" : { \"type\" : \"apiKey\" , \"in\" : \"header\" , \"name\" : \"X-API-KEY\" } } swagger_blueprint . url_prefix = \"/docs\" app . blueprint ( swagger_blueprint ) app . blueprint ( api . images . blueprint ) app . blueprint ( api . templates . blueprint ) app . blueprint ( api . shortcuts . blueprint ) CORS ( app ) app . error_handler = errors . BugsnagErrorHandler () @cached ({}, key = lambda x : 0 if settings . DEPLOYED else x ) # type: ignore def get_valid_templates ( request ) -> List [ Dict ]: templates = Template . objects . filter ( valid = True , _exclude = \"_custom\" ) return [ t . jsonify ( request . app ) for t in templates ] @cached ({}, key = lambda x : 0 if settings . DEPLOYED else x ) # type: ignore def get_sample_images ( request ) -> List [ Tuple [ str , str ]]: return [ ( template . build_sample_url ( request . app ), template . build_self_url ( request . app )) for template in Template . objects . filter ( valid = True , _exclude = \"_custom\" ) ] def get_test_images ( request ) -> List [ str ]: return [ request . app . url_for ( f \"images.text_{settings.DEFAULT_EXT}\" , template_key = key , text_paths = utils . text . encode ( lines ), ) for key , lines in settings . TEST_IMAGES ] async def track ( request , lines ): if settings . REMOTE_TRACKING_URL : # pragma: no cover async with aiohttp . ClientSession () as session : params = dict ( text = \" \" . join ( lines ), source = \"memegen.link\" , context = unquote ( request . url ), ) response = await session . get ( settings . REMOTE_TRACKING_URL , params = params ) if response . status != 200 : try : message = await response . json () except aiohttp . client_exceptions . ContentTypeError : message = response . text logger . error ( f \"Tracker response: {message}\" )","title":"Module app.helpers"},{"location":"reference/app/helpers/#functions","text":"","title":"Functions"},{"location":"reference/app/helpers/#configure","text":"def configure ( app ) View Source def configure ( app ) : app . config . API_HOST = app . config . SERVER_NAME = settings . SERVER_NAME app . config . API_BASEPATH = \"/\" app . config . API_SCHEMES = [ settings.SCHEME ] app . config . API_VERSION = \"6.2\" app . config . API_TITLE = \"Memegen API\" app . config . API_CONTACT_EMAIL = \"support@maketested.com\" app . config . API_LICENSE_NAME = \"View license\" app . config . API_LICENSE_URL = ( \"https://github.com/jacebrowning/memegen/blob/main/LICENSE.txt\" ) app . config . API_SECURITY = [ {\"ApiKeyAuth\": [ ] }] app . config . API_SECURITY_DEFINITIONS = { \"ApiKeyAuth\" : { \"type\" : \"apiKey\" , \"in\" : \"header\" , \"name\" : \"X-API-KEY\" } } swagger_blueprint . url_prefix = \"/docs\" app . blueprint ( swagger_blueprint ) app . blueprint ( api . images . blueprint ) app . blueprint ( api . templates . blueprint ) app . blueprint ( api . shortcuts . blueprint ) CORS ( app ) app . error_handler = errors . BugsnagErrorHandler ()","title":"configure"},{"location":"reference/app/helpers/#get_sample_images","text":"def get_sample_images ( request ) -> List [ Tuple [ str , str ]] View Source @cached ( {} , key = lambda x : 0 if settings . DEPLOYED else x ) # type : ignore def get_sample_images ( request ) -> List [ Tuple[str, str ] ]: return [ (template.build_sample_url(request.app), template.build_self_url(request.app)) for template in Template.objects.filter(valid=True, _exclude=\"_custom\") ]","title":"get_sample_images"},{"location":"reference/app/helpers/#get_test_images","text":"def get_test_images ( request ) -> List [ str ] View Source def get_test_images ( request ) -> List [ str ] : return [ request.app.url_for( f\"images.text_{settings.DEFAULT_EXT}\", template_key=key, text_paths=utils.text.encode(lines), ) for key, lines in settings.TEST_IMAGES ]","title":"get_test_images"},{"location":"reference/app/helpers/#get_valid_templates","text":"def get_valid_templates ( request ) -> List [ Dict ] View Source @cached ( {} , key = lambda x : 0 if settings . DEPLOYED else x ) # type : ignore def get_valid_templates ( request ) -> List [ Dict ] : templates = Template . objects . filter ( valid = True , _exclude = \"_custom\" ) return [ t.jsonify(request.app) for t in templates ]","title":"get_valid_templates"},{"location":"reference/app/helpers/#track","text":"def track ( request , lines ) View Source async def track ( request , lines ): if settings . REMOTE_TRACKING_URL : # pragma : no cover async with aiohttp . ClientSession () as session : params = dict ( text = \" \" . join ( lines ), source = \"memegen.link\" , context = unquote ( request . url ), ) response = await session . get ( settings . REMOTE_TRACKING_URL , params = params ) if response . status != 200 : try : message = await response . json () except aiohttp . client_exceptions . ContentTypeError : message = response . text logger . error ( f \"Tracker response: {message}\" )","title":"track"},{"location":"reference/app/models/","text":"Module app.models View Source import hashlib from pathlib import Path from typing import Dict , List , Optional from urllib.parse import urlparse import aiofiles import aiohttp from aiohttp.client_exceptions import ClientConnectionError , InvalidURL from datafiles import datafile , field from sanic import Sanic from sanic.log import logger from spongemock import spongemock from . import settings , utils from .types import Dimensions , Point @datafile class Text : color : str = \"white\" style : str = \"upper\" anchor_x : float = 0.0 anchor_y : float = 0.0 angle : float = 0 scale_x : float = 1.0 scale_y : float = 0.2 def get_anchor ( self , image_size : Dimensions ) -> Point : image_width , image_height = image_size return int ( image_width * self . anchor_x ), int ( image_height * self . anchor_y ) def get_size ( self , image_size : Dimensions ) -> Dimensions : image_width , image_height = image_size return int ( image_width * self . scale_x ), int ( image_height * self . scale_y ) def stylize ( self , text : str ) -> str : if self . style == \"none\" : return text if self . style == \"default\" : return text . capitalize () if text . islower () else text if self . style == \"mock\" : return spongemock . mock ( text , diversity_bias = 0.75 , random_seed = 0 ) method = getattr ( text , self . style or self . __class__ . style , None ) if method : return method () logger . warning ( f \"Unsupported text style: {self.style}\" ) return text @datafile ( \"../templates/{self.key}/config.yml\" , defaults = True ) class Template : key : str name : str = \"\" source : Optional [ str ] = None text : List [ Text ] = field ( default_factory = lambda : [ Text (), Text ( anchor_x = 0.0 , anchor_y = 0.8 )] ) styles : List [ str ] = field ( default_factory = lambda : [ settings . DEFAULT_STYLE ]) sample : List [ str ] = field ( default_factory = lambda : [ \"YOUR TEXT\" , \"GOES HERE\" ]) def __str__ ( self ): return str ( self . directory ) @property def valid ( self ) -> bool : if not settings . DEPLOYED : styles = [] for path in self . directory . iterdir (): if path . stem not in { \"config\" , settings . DEFAULT_STYLE }: styles . append ( path . stem ) styles . sort () if styles != self . styles : self . styles = styles return not self . key . startswith ( \"_\" ) and self . image . suffix != \".img\" @property def directory ( self ) -> Path : return self . datafile . path . parent @property def image ( self ) -> Path : return self . get_image () def get_image ( self , style : str = \"\" ) -> Path : style = style or settings . DEFAULT_STYLE self . directory . mkdir ( exist_ok = True ) for path in self . directory . iterdir (): if path . stem == style : return path if style == settings . DEFAULT_STYLE : logger . debug ( f \"No default background image for template: {self.key}\" ) return self . directory / f \"{settings.DEFAULT_STYLE}.img\" else : logger . warning ( f \"Style {style!r} not available for {self.key}\" ) return self . get_image () def jsonify ( self , app : Sanic ) -> Dict : return { \"name\" : self . name , \"key\" : self . key , \"styles\" : self . styles , \"blank\" : app . url_for ( f \"images.blank_{settings.DEFAULT_EXT}\" , template_key = self . key , _external = True , _scheme = settings . SCHEME , ), \"sample\" : self . build_sample_url ( app ), \"source\" : self . source , \"_self\" : self . build_self_url ( app ), } def build_self_url ( self , app : Sanic ) -> str : return app . url_for ( \"templates.detail\" , key = self . key , _external = True , _scheme = settings . SCHEME , ) def build_sample_url ( self , app : Sanic , view_name : str = f \"images.text_{settings.DEFAULT_EXT}\" , * , external : bool = True , ) -> str : kwargs = { \"template_key\" : self . key , \"text_paths\" : utils . text . encode ( self . sample ), \"_external\" : external , } if external : kwargs [ \"_scheme\" ] = settings . SCHEME return app . url_for ( view_name , ** kwargs ) def build_custom_url ( self , app : Sanic , text_lines : List [ str ], * , extension : str = \"\" , background : str = \"\" , external : bool = False , ): if extension in { \"jpg\" , \"png\" }: view_name = f \"images.text_{extension}\" else : view_name = f \"images.text_{settings.DEFAULT_EXT}\" url = app . url_for ( view_name , template_key = \"custom\" if self . key == \"_custom\" else self . key , text_paths = utils . text . encode ( text_lines ), _external = True , _scheme = settings . SCHEME , ) if background : url += \"?background=\" + background return url @classmethod async def create ( cls , url : str ) -> \"Template\" : parts = urlparse ( url ) if \"memegen.link\" in parts . netloc : logger . debug ( f \"Handling builtin template: {url}\" ) key = parts . path . split ( \".\" )[ 0 ] . split ( \"/\" )[ 2 ] return cls . objects . get ( key ) key = \"_custom-\" + hashlib . sha1 ( url . encode ()) . hexdigest () template = cls . objects . get_or_create ( key , url ) if template . image . exists () and not settings . DEBUG : logger . info ( f \"Found background {url} at {template.image}\" ) else : logger . info ( f \"Saving background {url} to {template.image}\" ) async with aiohttp . ClientSession () as session : try : async with session . get ( url ) as response : if response . status == 200 : template . directory . mkdir ( exist_ok = True ) f = await aiofiles . open ( template . image , mode = \"wb\" ) # type: ignore await f . write ( await response . read ()) await f . close () else : logger . error ( f \"{response.status} response from {url}\" ) except ( InvalidURL , ClientConnectionError ): logger . error ( f \"Invalid response from {url}\" ) if template . image . exists (): try : utils . images . load ( template . image ) except OSError as e : logger . error ( e ) template . image . unlink () return template Classes Template class Template ( * args , ** kwargs ) Template(key: str, name: str = '', source: Union[str, NoneType] = None, text: List[app.models.Text] = , styles: List[str] = , sample: List[str] = ) View Source class Template : key : str name : str = \"\" source : Optional [ str ] = None text : List [ Text ] = field ( default_factory = lambda : [ Text(), Text(anchor_x=0.0, anchor_y=0.8) ] ) styles : List [ str ] = field ( default_factory = lambda : [ settings.DEFAULT_STYLE ] ) sample : List [ str ] = field ( default_factory = lambda : [ \"YOUR TEXT\", \"GOES HERE\" ] ) def __str__ ( self ) : return str ( self . directory ) @property def valid ( self ) -> bool : if not settings . DEPLOYED : styles = [] for path in self . directory . iterdir () : if path . stem not in { \"config\" , settings . DEFAULT_STYLE }: styles . append ( path . stem ) styles . sort () if styles != self . styles : self . styles = styles return not self . key . startswith ( \"_\" ) and self . image . suffix != \".img\" @property def directory ( self ) -> Path : return self . datafile . path . parent @property def image ( self ) -> Path : return self . get_image () def get_image ( self , style : str = \"\" ) -> Path : style = style or settings . DEFAULT_STYLE self . directory . mkdir ( exist_ok = True ) for path in self . directory . iterdir () : if path . stem == style : return path if style == settings . DEFAULT_STYLE : logger . debug ( f \"No default background image for template: {self.key}\" ) return self . directory / f \"{settings.DEFAULT_STYLE}.img\" else : logger . warning ( f \"Style {style!r} not available for {self.key}\" ) return self . get_image () def jsonify ( self , app : Sanic ) -> Dict : return { \"name\" : self . name , \"key\" : self . key , \"styles\" : self . styles , \"blank\" : app . url_for ( f \"images.blank_{settings.DEFAULT_EXT}\" , template_key = self . key , _external = True , _scheme = settings . SCHEME , ), \"sample\" : self . build_sample_url ( app ), \"source\" : self . source , \"_self\" : self . build_self_url ( app ), } def build_self_url ( self , app : Sanic ) -> str : return app . url_for ( \"templates.detail\" , key = self . key , _external = True , _scheme = settings . SCHEME , ) def build_sample_url ( self , app : Sanic , view_name : str = f \"images.text_{settings.DEFAULT_EXT}\" , * , external : bool = True , ) -> str : kwargs = { \"template_key\" : self . key , \"text_paths\" : utils . text . encode ( self . sample ), \"_external\" : external , } if external : kwargs [ \"_scheme\" ] = settings . SCHEME return app . url_for ( view_name , ** kwargs ) def build_custom_url ( self , app : Sanic , text_lines : List [ str ] , * , extension : str = \"\" , background : str = \"\" , external : bool = False , ) : if extension in { \"jpg\" , \"png\" }: view_name = f \"images.text_{extension}\" else : view_name = f \"images.text_{settings.DEFAULT_EXT}\" url = app . url_for ( view_name , template_key = \"custom\" if self . key == \"_custom\" else self . key , text_paths = utils . text . encode ( text_lines ), _external = True , _scheme = settings . SCHEME , ) if background : url += \"?background=\" + background return url @classmethod async def create ( cls , url : str ) -> \"Template\" : parts = urlparse ( url ) if \"memegen.link\" in parts . netloc : logger . debug ( f \"Handling builtin template: {url}\" ) key = parts . path . split ( \".\" ) [ 0 ] . split ( \"/\" ) [ 2 ] return cls . objects . get ( key ) key = \"_custom-\" + hashlib . sha1 ( url . encode ()). hexdigest () template = cls . objects . get_or_create ( key , url ) if template . image . exists () and not settings . DEBUG : logger . info ( f \"Found background {url} at {template.image}\" ) else : logger . info ( f \"Saving background {url} to {template.image}\" ) async with aiohttp . ClientSession () as session : try : async with session . get ( url ) as response : if response . status == 200 : template . directory . mkdir ( exist_ok = True ) f = await aiofiles . open ( template . image , mode = \"wb\" ) # type : ignore await f . write ( await response . read ()) await f . close () else : logger . error ( f \"{response.status} response from {url}\" ) except ( InvalidURL , ClientConnectionError ) : logger . error ( f \"Invalid response from {url}\" ) if template . image . exists () : try : utils . images . load ( template . image ) except OSError as e : logger . error ( e ) template . image . unlink () return template Class variables Meta name objects source Static methods create def create ( url : str ) -> 'Template' View Source @ classmethod async def create ( cls , url : str ) -> \"Template\" : parts = urlparse ( url ) if \"memegen.link\" in parts . netloc : logger . debug ( f \"Handling builtin template: {url}\" ) key = parts . path . split ( \".\" )[ 0 ] . split ( \"/\" )[ 2 ] return cls . objects . get ( key ) key = \"_custom-\" + hashlib . sha1 ( url . encode ()) . hexdigest () template = cls . objects . get_or_create ( key , url ) if template . image . exists () and not settings . DEBUG : logger . info ( f \"Found background {url} at {template.image}\" ) else : logger . info ( f \"Saving background {url} to {template.image}\" ) async with aiohttp . ClientSession () as session : try : async with session . get ( url ) as response : if response . status == 200 : template . directory . mkdir ( exist_ok = True ) f = await aiofiles . open ( template . image , mode = \"wb\" ) # type: ignore await f . write ( await response . read ()) await f . close () else : logger . error ( f \"{response.status} response from {url}\" ) except ( InvalidURL , ClientConnectionError ): logger . error ( f \"Invalid response from {url}\" ) if template . image . exists (): try : utils . images . load ( template . image ) except OSError as e : logger . error ( e ) template . image . unlink () return template Instance variables directory image valid Methods build_custom_url def build_custom_url ( self , app : sanic . app . Sanic , text_lines : List [ str ], * , extension : str = '' , background : str = '' , external : bool = False ) View Source def build_custom_url ( self , app : Sanic , text_lines : List [ str ] , * , extension : str = \"\" , background : str = \"\" , external : bool = False , ) : if extension in { \"jpg\" , \"png\" }: view_name = f \"images.text_{extension}\" else : view_name = f \"images.text_{settings.DEFAULT_EXT}\" url = app . url_for ( view_name , template_key = \"custom\" if self . key == \"_custom\" else self . key , text_paths = utils . text . encode ( text_lines ), _external = True , _scheme = settings . SCHEME , ) if background : url += \"?background=\" + background return url build_sample_url def build_sample_url ( self , app : sanic . app . Sanic , view_name : str = 'images.text_png' , * , external : bool = True ) -> str View Source def build_sample_url ( self , app : Sanic , view_name : str = f \"images.text_{settings.DEFAULT_EXT}\" , * , external : bool = True , ) -> str : kwargs = { \"template_key\" : self . key , \"text_paths\" : utils . text . encode ( self . sample ), \"_external\" : external , } if external : kwargs [ \"_scheme\" ] = settings . SCHEME return app . url_for ( view_name , ** kwargs ) build_self_url def build_self_url ( self , app : sanic . app . Sanic ) -> str View Source def build_self_url ( self , app : Sanic ) -> str : return app . url_for ( \"templates.detail\" , key = self . key , _external = True , _scheme = settings . SCHEME , ) get_image def get_image ( self , style : str = '' ) -> pathlib . Path View Source def get_image ( self , style : str = \"\" ) -> Path : style = style or settings . DEFAULT_STYLE self . directory . mkdir ( exist_ok = True ) for path in self . directory . iterdir (): if path . stem == style : return path if style == settings . DEFAULT_STYLE : logger . debug ( f \"No default background image for template: {self.key}\" ) return self . directory / f \"{settings.DEFAULT_STYLE}.img\" else : logger . warning ( f \"Style {style!r} not available for {self.key}\" ) return self . get_image () jsonify def jsonify ( self , app : sanic . app . Sanic ) -> Dict View Source def jsonify ( self , app : Sanic ) -> Dict : return { \"name\" : self . name , \"key\" : self . key , \"styles\" : self . styles , \"blank\" : app . url_for ( f \"images.blank_{settings.DEFAULT_EXT}\" , template_key = self . key , _external = True , _scheme = settings . SCHEME , ), \"sample\" : self . build_sample_url ( app ), \"source\" : self . source , \"_self\" : self . build_self_url ( app ), } Text class Text ( color : str = 'white' , style : str = 'upper' , anchor_x : float = 0.0 , anchor_y : float = 0.0 , angle : float = 0 , scale_x : float = 1.0 , scale_y : float = 0.2 ) Text(color: str = 'white', style: str = 'upper', anchor_x: float = 0.0, anchor_y: float = 0.0, angle: float = 0, scale_x: float = 1.0, scale_y: float = 0.2) View Source class Text: color: str = \"white\" style: str = \"upper\" anchor_x: float = 0.0 anchor_y: float = 0.0 angle: float = 0 scale_x: float = 1.0 scale_y: float = 0.2 def get_anchor ( self , image_size: Dimensions ) -> Point: image_width , image_height = image_size return int ( image_width * self . anchor_x ), int ( image_height * self . anchor_y ) def get_size ( self , image_size: Dimensions ) -> Dimensions: image_width , image_height = image_size return int ( image_width * self . scale_x ), int ( image_height * self . scale_y ) def stylize ( self , text: str ) -> str: if self . style == \"none\" : return text if self . style == \"default\" : return text . capitalize () if text . islower () else text if self . style == \"mock\" : return spongemock . mock ( text , diversity_bias = 0.75 , random_seed = 0 ) method = getattr ( text , self . style or self . __class__ . style , None ) if method: return method () logger . warning ( f \"Unsupported text style: {self.style}\" ) return text Class variables anchor_x anchor_y angle color scale_x scale_y style Methods get_anchor def get_anchor ( self , image_size : Tuple [ int , int ] ) -> Tuple [ int , int ] View Source def get_anchor ( self , image_size : Dimensions ) -> Point : image_width , image_height = image_size return int ( image_width * self . anchor_x ), int ( image_height * self . anchor_y ) get_size def get_size ( self , image_size : Tuple [ int , int ] ) -> Tuple [ int , int ] View Source def get_size ( self , image_size : Dimensions ) -> Dimensions : image_width , image_height = image_size return int ( image_width * self . scale_x ), int ( image_height * self . scale_y ) stylize def stylize ( self , text : str ) -> str View Source def stylize ( self , text : str ) -> str : if self . style == \"none\" : return text if self . style == \"default\" : return text . capitalize () if text . islower () else text if self . style == \"mock\" : return spongemock . mock ( text , diversity_bias = 0 . 75 , random_seed = 0 ) method = getattr ( text , self . style or self . __class__ . style , None ) if method : return method () logger . warning ( f \"Unsupported text style: {self.style}\" ) return text","title":"Models"},{"location":"reference/app/models/#module-appmodels","text":"View Source import hashlib from pathlib import Path from typing import Dict , List , Optional from urllib.parse import urlparse import aiofiles import aiohttp from aiohttp.client_exceptions import ClientConnectionError , InvalidURL from datafiles import datafile , field from sanic import Sanic from sanic.log import logger from spongemock import spongemock from . import settings , utils from .types import Dimensions , Point @datafile class Text : color : str = \"white\" style : str = \"upper\" anchor_x : float = 0.0 anchor_y : float = 0.0 angle : float = 0 scale_x : float = 1.0 scale_y : float = 0.2 def get_anchor ( self , image_size : Dimensions ) -> Point : image_width , image_height = image_size return int ( image_width * self . anchor_x ), int ( image_height * self . anchor_y ) def get_size ( self , image_size : Dimensions ) -> Dimensions : image_width , image_height = image_size return int ( image_width * self . scale_x ), int ( image_height * self . scale_y ) def stylize ( self , text : str ) -> str : if self . style == \"none\" : return text if self . style == \"default\" : return text . capitalize () if text . islower () else text if self . style == \"mock\" : return spongemock . mock ( text , diversity_bias = 0.75 , random_seed = 0 ) method = getattr ( text , self . style or self . __class__ . style , None ) if method : return method () logger . warning ( f \"Unsupported text style: {self.style}\" ) return text @datafile ( \"../templates/{self.key}/config.yml\" , defaults = True ) class Template : key : str name : str = \"\" source : Optional [ str ] = None text : List [ Text ] = field ( default_factory = lambda : [ Text (), Text ( anchor_x = 0.0 , anchor_y = 0.8 )] ) styles : List [ str ] = field ( default_factory = lambda : [ settings . DEFAULT_STYLE ]) sample : List [ str ] = field ( default_factory = lambda : [ \"YOUR TEXT\" , \"GOES HERE\" ]) def __str__ ( self ): return str ( self . directory ) @property def valid ( self ) -> bool : if not settings . DEPLOYED : styles = [] for path in self . directory . iterdir (): if path . stem not in { \"config\" , settings . DEFAULT_STYLE }: styles . append ( path . stem ) styles . sort () if styles != self . styles : self . styles = styles return not self . key . startswith ( \"_\" ) and self . image . suffix != \".img\" @property def directory ( self ) -> Path : return self . datafile . path . parent @property def image ( self ) -> Path : return self . get_image () def get_image ( self , style : str = \"\" ) -> Path : style = style or settings . DEFAULT_STYLE self . directory . mkdir ( exist_ok = True ) for path in self . directory . iterdir (): if path . stem == style : return path if style == settings . DEFAULT_STYLE : logger . debug ( f \"No default background image for template: {self.key}\" ) return self . directory / f \"{settings.DEFAULT_STYLE}.img\" else : logger . warning ( f \"Style {style!r} not available for {self.key}\" ) return self . get_image () def jsonify ( self , app : Sanic ) -> Dict : return { \"name\" : self . name , \"key\" : self . key , \"styles\" : self . styles , \"blank\" : app . url_for ( f \"images.blank_{settings.DEFAULT_EXT}\" , template_key = self . key , _external = True , _scheme = settings . SCHEME , ), \"sample\" : self . build_sample_url ( app ), \"source\" : self . source , \"_self\" : self . build_self_url ( app ), } def build_self_url ( self , app : Sanic ) -> str : return app . url_for ( \"templates.detail\" , key = self . key , _external = True , _scheme = settings . SCHEME , ) def build_sample_url ( self , app : Sanic , view_name : str = f \"images.text_{settings.DEFAULT_EXT}\" , * , external : bool = True , ) -> str : kwargs = { \"template_key\" : self . key , \"text_paths\" : utils . text . encode ( self . sample ), \"_external\" : external , } if external : kwargs [ \"_scheme\" ] = settings . SCHEME return app . url_for ( view_name , ** kwargs ) def build_custom_url ( self , app : Sanic , text_lines : List [ str ], * , extension : str = \"\" , background : str = \"\" , external : bool = False , ): if extension in { \"jpg\" , \"png\" }: view_name = f \"images.text_{extension}\" else : view_name = f \"images.text_{settings.DEFAULT_EXT}\" url = app . url_for ( view_name , template_key = \"custom\" if self . key == \"_custom\" else self . key , text_paths = utils . text . encode ( text_lines ), _external = True , _scheme = settings . SCHEME , ) if background : url += \"?background=\" + background return url @classmethod async def create ( cls , url : str ) -> \"Template\" : parts = urlparse ( url ) if \"memegen.link\" in parts . netloc : logger . debug ( f \"Handling builtin template: {url}\" ) key = parts . path . split ( \".\" )[ 0 ] . split ( \"/\" )[ 2 ] return cls . objects . get ( key ) key = \"_custom-\" + hashlib . sha1 ( url . encode ()) . hexdigest () template = cls . objects . get_or_create ( key , url ) if template . image . exists () and not settings . DEBUG : logger . info ( f \"Found background {url} at {template.image}\" ) else : logger . info ( f \"Saving background {url} to {template.image}\" ) async with aiohttp . ClientSession () as session : try : async with session . get ( url ) as response : if response . status == 200 : template . directory . mkdir ( exist_ok = True ) f = await aiofiles . open ( template . image , mode = \"wb\" ) # type: ignore await f . write ( await response . read ()) await f . close () else : logger . error ( f \"{response.status} response from {url}\" ) except ( InvalidURL , ClientConnectionError ): logger . error ( f \"Invalid response from {url}\" ) if template . image . exists (): try : utils . images . load ( template . image ) except OSError as e : logger . error ( e ) template . image . unlink () return template","title":"Module app.models"},{"location":"reference/app/models/#classes","text":"","title":"Classes"},{"location":"reference/app/models/#template","text":"class Template ( * args , ** kwargs ) Template(key: str, name: str = '', source: Union[str, NoneType] = None, text: List[app.models.Text] = , styles: List[str] = , sample: List[str] = ) View Source class Template : key : str name : str = \"\" source : Optional [ str ] = None text : List [ Text ] = field ( default_factory = lambda : [ Text(), Text(anchor_x=0.0, anchor_y=0.8) ] ) styles : List [ str ] = field ( default_factory = lambda : [ settings.DEFAULT_STYLE ] ) sample : List [ str ] = field ( default_factory = lambda : [ \"YOUR TEXT\", \"GOES HERE\" ] ) def __str__ ( self ) : return str ( self . directory ) @property def valid ( self ) -> bool : if not settings . DEPLOYED : styles = [] for path in self . directory . iterdir () : if path . stem not in { \"config\" , settings . DEFAULT_STYLE }: styles . append ( path . stem ) styles . sort () if styles != self . styles : self . styles = styles return not self . key . startswith ( \"_\" ) and self . image . suffix != \".img\" @property def directory ( self ) -> Path : return self . datafile . path . parent @property def image ( self ) -> Path : return self . get_image () def get_image ( self , style : str = \"\" ) -> Path : style = style or settings . DEFAULT_STYLE self . directory . mkdir ( exist_ok = True ) for path in self . directory . iterdir () : if path . stem == style : return path if style == settings . DEFAULT_STYLE : logger . debug ( f \"No default background image for template: {self.key}\" ) return self . directory / f \"{settings.DEFAULT_STYLE}.img\" else : logger . warning ( f \"Style {style!r} not available for {self.key}\" ) return self . get_image () def jsonify ( self , app : Sanic ) -> Dict : return { \"name\" : self . name , \"key\" : self . key , \"styles\" : self . styles , \"blank\" : app . url_for ( f \"images.blank_{settings.DEFAULT_EXT}\" , template_key = self . key , _external = True , _scheme = settings . SCHEME , ), \"sample\" : self . build_sample_url ( app ), \"source\" : self . source , \"_self\" : self . build_self_url ( app ), } def build_self_url ( self , app : Sanic ) -> str : return app . url_for ( \"templates.detail\" , key = self . key , _external = True , _scheme = settings . SCHEME , ) def build_sample_url ( self , app : Sanic , view_name : str = f \"images.text_{settings.DEFAULT_EXT}\" , * , external : bool = True , ) -> str : kwargs = { \"template_key\" : self . key , \"text_paths\" : utils . text . encode ( self . sample ), \"_external\" : external , } if external : kwargs [ \"_scheme\" ] = settings . SCHEME return app . url_for ( view_name , ** kwargs ) def build_custom_url ( self , app : Sanic , text_lines : List [ str ] , * , extension : str = \"\" , background : str = \"\" , external : bool = False , ) : if extension in { \"jpg\" , \"png\" }: view_name = f \"images.text_{extension}\" else : view_name = f \"images.text_{settings.DEFAULT_EXT}\" url = app . url_for ( view_name , template_key = \"custom\" if self . key == \"_custom\" else self . key , text_paths = utils . text . encode ( text_lines ), _external = True , _scheme = settings . SCHEME , ) if background : url += \"?background=\" + background return url @classmethod async def create ( cls , url : str ) -> \"Template\" : parts = urlparse ( url ) if \"memegen.link\" in parts . netloc : logger . debug ( f \"Handling builtin template: {url}\" ) key = parts . path . split ( \".\" ) [ 0 ] . split ( \"/\" ) [ 2 ] return cls . objects . get ( key ) key = \"_custom-\" + hashlib . sha1 ( url . encode ()). hexdigest () template = cls . objects . get_or_create ( key , url ) if template . image . exists () and not settings . DEBUG : logger . info ( f \"Found background {url} at {template.image}\" ) else : logger . info ( f \"Saving background {url} to {template.image}\" ) async with aiohttp . ClientSession () as session : try : async with session . get ( url ) as response : if response . status == 200 : template . directory . mkdir ( exist_ok = True ) f = await aiofiles . open ( template . image , mode = \"wb\" ) # type : ignore await f . write ( await response . read ()) await f . close () else : logger . error ( f \"{response.status} response from {url}\" ) except ( InvalidURL , ClientConnectionError ) : logger . error ( f \"Invalid response from {url}\" ) if template . image . exists () : try : utils . images . load ( template . image ) except OSError as e : logger . error ( e ) template . image . unlink () return template","title":"Template"},{"location":"reference/app/models/#class-variables","text":"Meta name objects source","title":"Class variables"},{"location":"reference/app/models/#static-methods","text":"","title":"Static methods"},{"location":"reference/app/models/#create","text":"def create ( url : str ) -> 'Template' View Source @ classmethod async def create ( cls , url : str ) -> \"Template\" : parts = urlparse ( url ) if \"memegen.link\" in parts . netloc : logger . debug ( f \"Handling builtin template: {url}\" ) key = parts . path . split ( \".\" )[ 0 ] . split ( \"/\" )[ 2 ] return cls . objects . get ( key ) key = \"_custom-\" + hashlib . sha1 ( url . encode ()) . hexdigest () template = cls . objects . get_or_create ( key , url ) if template . image . exists () and not settings . DEBUG : logger . info ( f \"Found background {url} at {template.image}\" ) else : logger . info ( f \"Saving background {url} to {template.image}\" ) async with aiohttp . ClientSession () as session : try : async with session . get ( url ) as response : if response . status == 200 : template . directory . mkdir ( exist_ok = True ) f = await aiofiles . open ( template . image , mode = \"wb\" ) # type: ignore await f . write ( await response . read ()) await f . close () else : logger . error ( f \"{response.status} response from {url}\" ) except ( InvalidURL , ClientConnectionError ): logger . error ( f \"Invalid response from {url}\" ) if template . image . exists (): try : utils . images . load ( template . image ) except OSError as e : logger . error ( e ) template . image . unlink () return template","title":"create"},{"location":"reference/app/models/#instance-variables","text":"directory image valid","title":"Instance variables"},{"location":"reference/app/models/#methods","text":"","title":"Methods"},{"location":"reference/app/models/#build_custom_url","text":"def build_custom_url ( self , app : sanic . app . Sanic , text_lines : List [ str ], * , extension : str = '' , background : str = '' , external : bool = False ) View Source def build_custom_url ( self , app : Sanic , text_lines : List [ str ] , * , extension : str = \"\" , background : str = \"\" , external : bool = False , ) : if extension in { \"jpg\" , \"png\" }: view_name = f \"images.text_{extension}\" else : view_name = f \"images.text_{settings.DEFAULT_EXT}\" url = app . url_for ( view_name , template_key = \"custom\" if self . key == \"_custom\" else self . key , text_paths = utils . text . encode ( text_lines ), _external = True , _scheme = settings . SCHEME , ) if background : url += \"?background=\" + background return url","title":"build_custom_url"},{"location":"reference/app/models/#build_sample_url","text":"def build_sample_url ( self , app : sanic . app . Sanic , view_name : str = 'images.text_png' , * , external : bool = True ) -> str View Source def build_sample_url ( self , app : Sanic , view_name : str = f \"images.text_{settings.DEFAULT_EXT}\" , * , external : bool = True , ) -> str : kwargs = { \"template_key\" : self . key , \"text_paths\" : utils . text . encode ( self . sample ), \"_external\" : external , } if external : kwargs [ \"_scheme\" ] = settings . SCHEME return app . url_for ( view_name , ** kwargs )","title":"build_sample_url"},{"location":"reference/app/models/#build_self_url","text":"def build_self_url ( self , app : sanic . app . Sanic ) -> str View Source def build_self_url ( self , app : Sanic ) -> str : return app . url_for ( \"templates.detail\" , key = self . key , _external = True , _scheme = settings . SCHEME , )","title":"build_self_url"},{"location":"reference/app/models/#get_image","text":"def get_image ( self , style : str = '' ) -> pathlib . Path View Source def get_image ( self , style : str = \"\" ) -> Path : style = style or settings . DEFAULT_STYLE self . directory . mkdir ( exist_ok = True ) for path in self . directory . iterdir (): if path . stem == style : return path if style == settings . DEFAULT_STYLE : logger . debug ( f \"No default background image for template: {self.key}\" ) return self . directory / f \"{settings.DEFAULT_STYLE}.img\" else : logger . warning ( f \"Style {style!r} not available for {self.key}\" ) return self . get_image ()","title":"get_image"},{"location":"reference/app/models/#jsonify","text":"def jsonify ( self , app : sanic . app . Sanic ) -> Dict View Source def jsonify ( self , app : Sanic ) -> Dict : return { \"name\" : self . name , \"key\" : self . key , \"styles\" : self . styles , \"blank\" : app . url_for ( f \"images.blank_{settings.DEFAULT_EXT}\" , template_key = self . key , _external = True , _scheme = settings . SCHEME , ), \"sample\" : self . build_sample_url ( app ), \"source\" : self . source , \"_self\" : self . build_self_url ( app ), }","title":"jsonify"},{"location":"reference/app/models/#text","text":"class Text ( color : str = 'white' , style : str = 'upper' , anchor_x : float = 0.0 , anchor_y : float = 0.0 , angle : float = 0 , scale_x : float = 1.0 , scale_y : float = 0.2 ) Text(color: str = 'white', style: str = 'upper', anchor_x: float = 0.0, anchor_y: float = 0.0, angle: float = 0, scale_x: float = 1.0, scale_y: float = 0.2) View Source class Text: color: str = \"white\" style: str = \"upper\" anchor_x: float = 0.0 anchor_y: float = 0.0 angle: float = 0 scale_x: float = 1.0 scale_y: float = 0.2 def get_anchor ( self , image_size: Dimensions ) -> Point: image_width , image_height = image_size return int ( image_width * self . anchor_x ), int ( image_height * self . anchor_y ) def get_size ( self , image_size: Dimensions ) -> Dimensions: image_width , image_height = image_size return int ( image_width * self . scale_x ), int ( image_height * self . scale_y ) def stylize ( self , text: str ) -> str: if self . style == \"none\" : return text if self . style == \"default\" : return text . capitalize () if text . islower () else text if self . style == \"mock\" : return spongemock . mock ( text , diversity_bias = 0.75 , random_seed = 0 ) method = getattr ( text , self . style or self . __class__ . style , None ) if method: return method () logger . warning ( f \"Unsupported text style: {self.style}\" ) return text","title":"Text"},{"location":"reference/app/models/#class-variables_1","text":"anchor_x anchor_y angle color scale_x scale_y style","title":"Class variables"},{"location":"reference/app/models/#methods_1","text":"","title":"Methods"},{"location":"reference/app/models/#get_anchor","text":"def get_anchor ( self , image_size : Tuple [ int , int ] ) -> Tuple [ int , int ] View Source def get_anchor ( self , image_size : Dimensions ) -> Point : image_width , image_height = image_size return int ( image_width * self . anchor_x ), int ( image_height * self . anchor_y )","title":"get_anchor"},{"location":"reference/app/models/#get_size","text":"def get_size ( self , image_size : Tuple [ int , int ] ) -> Tuple [ int , int ] View Source def get_size ( self , image_size : Dimensions ) -> Dimensions : image_width , image_height = image_size return int ( image_width * self . scale_x ), int ( image_height * self . scale_y )","title":"get_size"},{"location":"reference/app/models/#stylize","text":"def stylize ( self , text : str ) -> str View Source def stylize ( self , text : str ) -> str : if self . style == \"none\" : return text if self . style == \"default\" : return text . capitalize () if text . islower () else text if self . style == \"mock\" : return spongemock . mock ( text , diversity_bias = 0 . 75 , random_seed = 0 ) method = getattr ( text , self . style or self . __class__ . style , None ) if method : return method () logger . warning ( f \"Unsupported text style: {self.style}\" ) return text","title":"stylize"},{"location":"reference/app/settings/","text":"Module app.settings View Source import os from pathlib import Path ROOT = Path ( __file__ ) . parent . parent . resolve () # Server configuration PORT = int ( os . environ . get ( \"PORT\" , 5000 )) WORKERS = int ( os . environ . get ( \"WEB_CONCURRENCY\" , 1 )) if \"DOMAIN\" in os . environ : # staging / production SERVER_NAME = os . environ [ \"DOMAIN\" ] RELEASE_STAGE = \"staging\" if \"staging\" in SERVER_NAME else \"production\" SCHEME = \"https\" elif \"HEROKU_APP_NAME\" in os . environ : # review apps SERVER_NAME = os . environ [ \"HEROKU_APP_NAME\" ] + \".herokuapp.com\" RELEASE_STAGE = \"review\" SCHEME = \"https\" else : # localhost SERVER_NAME = f \"localhost:{PORT}\" RELEASE_STAGE = \"local\" SCHEME = \"http\" DEPLOYED = RELEASE_STAGE != \"local\" or \"WEB_CONCURRENCY\" in os . environ BUGSNAG_API_KEY = os . getenv ( \"BUGSNAG_API_KEY\" ) DEBUG = bool ( os . environ . get ( \"DEBUG\" , False )) # Fonts FONTS_DIRECTORY = ROOT / \"fonts\" FONT_THIN = FONTS_DIRECTORY / \"TitilliumWeb-SemiBold.ttf\" FONT_THICK = FONTS_DIRECTORY / \"TitilliumWeb-Black.ttf\" # Image rendering IMAGES_DIRECTORY = ROOT / \"images\" DEFAULT_EXT = \"png\" DEFAULT_STYLE = \"default\" PREVIEW_SIZE = ( 300 , 300 ) DEFAULT_SIZE = ( 600 , 600 ) MAXIMUM_PIXELS = 1920 * 1080 # Test images TEST_IMAGES_DIRECTORY = ROOT / \"app\" / \"tests\" / \"images\" TEST_IMAGES = [ ( \"iw\" , [ \"tests code\" , \"in production\" ], ), ( \"fry\" , [ \"a\" , \"b\" ], ), ( \"fry\" , [ \"short line\" , \"longer line of text than the short one\" ], ), ( \"fry\" , [ \"longer line of text than the short one\" , \"short line\" ], ), ( \"sparta\" , [ \"\" , \"this is a wide image!\" ], ), ( \"ski\" , [ \"if you try to put a bunch more text than can possibly fit on a meme\" , \"you're gonna have a bad time\" , ], ), ( \"ds\" , [ \"Push this button.\" , \"Push that button.\" , \"can't decide which is worse\" ], ), ( \"spongebob\" , [ \"You: Stop talking like that\" , \"Me: Stop talking like that\" ], ), ] # Analytics REMOTE_TRACKING_URL = os . getenv ( \"REMOTE_TRACKING_URL\" ) Variables BUGSNAG_API_KEY DEBUG DEFAULT_EXT DEFAULT_SIZE DEFAULT_STYLE DEPLOYED FONTS_DIRECTORY FONT_THICK FONT_THIN IMAGES_DIRECTORY MAXIMUM_PIXELS PORT PREVIEW_SIZE RELEASE_STAGE REMOTE_TRACKING_URL ROOT SCHEME SERVER_NAME TEST_IMAGES TEST_IMAGES_DIRECTORY WORKERS","title":"Settings"},{"location":"reference/app/settings/#module-appsettings","text":"View Source import os from pathlib import Path ROOT = Path ( __file__ ) . parent . parent . resolve () # Server configuration PORT = int ( os . environ . get ( \"PORT\" , 5000 )) WORKERS = int ( os . environ . get ( \"WEB_CONCURRENCY\" , 1 )) if \"DOMAIN\" in os . environ : # staging / production SERVER_NAME = os . environ [ \"DOMAIN\" ] RELEASE_STAGE = \"staging\" if \"staging\" in SERVER_NAME else \"production\" SCHEME = \"https\" elif \"HEROKU_APP_NAME\" in os . environ : # review apps SERVER_NAME = os . environ [ \"HEROKU_APP_NAME\" ] + \".herokuapp.com\" RELEASE_STAGE = \"review\" SCHEME = \"https\" else : # localhost SERVER_NAME = f \"localhost:{PORT}\" RELEASE_STAGE = \"local\" SCHEME = \"http\" DEPLOYED = RELEASE_STAGE != \"local\" or \"WEB_CONCURRENCY\" in os . environ BUGSNAG_API_KEY = os . getenv ( \"BUGSNAG_API_KEY\" ) DEBUG = bool ( os . environ . get ( \"DEBUG\" , False )) # Fonts FONTS_DIRECTORY = ROOT / \"fonts\" FONT_THIN = FONTS_DIRECTORY / \"TitilliumWeb-SemiBold.ttf\" FONT_THICK = FONTS_DIRECTORY / \"TitilliumWeb-Black.ttf\" # Image rendering IMAGES_DIRECTORY = ROOT / \"images\" DEFAULT_EXT = \"png\" DEFAULT_STYLE = \"default\" PREVIEW_SIZE = ( 300 , 300 ) DEFAULT_SIZE = ( 600 , 600 ) MAXIMUM_PIXELS = 1920 * 1080 # Test images TEST_IMAGES_DIRECTORY = ROOT / \"app\" / \"tests\" / \"images\" TEST_IMAGES = [ ( \"iw\" , [ \"tests code\" , \"in production\" ], ), ( \"fry\" , [ \"a\" , \"b\" ], ), ( \"fry\" , [ \"short line\" , \"longer line of text than the short one\" ], ), ( \"fry\" , [ \"longer line of text than the short one\" , \"short line\" ], ), ( \"sparta\" , [ \"\" , \"this is a wide image!\" ], ), ( \"ski\" , [ \"if you try to put a bunch more text than can possibly fit on a meme\" , \"you're gonna have a bad time\" , ], ), ( \"ds\" , [ \"Push this button.\" , \"Push that button.\" , \"can't decide which is worse\" ], ), ( \"spongebob\" , [ \"You: Stop talking like that\" , \"Me: Stop talking like that\" ], ), ] # Analytics REMOTE_TRACKING_URL = os . getenv ( \"REMOTE_TRACKING_URL\" )","title":"Module app.settings"},{"location":"reference/app/settings/#variables","text":"BUGSNAG_API_KEY DEBUG DEFAULT_EXT DEFAULT_SIZE DEFAULT_STYLE DEPLOYED FONTS_DIRECTORY FONT_THICK FONT_THIN IMAGES_DIRECTORY MAXIMUM_PIXELS PORT PREVIEW_SIZE RELEASE_STAGE REMOTE_TRACKING_URL ROOT SCHEME SERVER_NAME TEST_IMAGES TEST_IMAGES_DIRECTORY WORKERS","title":"Variables"},{"location":"reference/app/types/","text":"Module app.types View Source from typing import Tuple Dimensions = Tuple [ int , int ] Point = Tuple [ int , int ] Offset = Tuple [ int , int ] Variables Dimensions Offset Point","title":"Types"},{"location":"reference/app/types/#module-apptypes","text":"View Source from typing import Tuple Dimensions = Tuple [ int , int ] Point = Tuple [ int , int ] Offset = Tuple [ int , int ]","title":"Module app.types"},{"location":"reference/app/types/#variables","text":"Dimensions Offset Point","title":"Variables"},{"location":"reference/app/views/","text":"Module app.views View Source import asyncio from pathlib import Path import log from markdown import markdown from sanic import Sanic , response from sanic_jinja2 import SanicJinja2 from sanic_openapi import doc from app import helpers , settings , utils app = Sanic ( name = \"memegen\" ) helpers . configure ( app ) jinja = SanicJinja2 ( app , pkg_name = \"app\" ) @app.get ( \"/\" ) @doc.exclude ( True ) @jinja.template ( \"index.html\" ) async def index ( request ): html = markdown ( text = Path ( \"README.md\" ) . read_text (), extensions = [ \"markdown.extensions.tables\" ], ) html = html . replace ( \"<code></code>\" , \"<code>&nbsp</code>\" ) html = html . replace ( \"https://api.memegen.link\" , f \"{settings.SCHEME}://{settings.SERVER_NAME}\" , ) return { \"content\" : html } @app.get ( \"/samples\" ) @doc.exclude ( True ) async def samples ( request ): samples = await asyncio . to_thread ( helpers . get_sample_images , request ) urls = [ sample [ 0 ] for sample in samples ] refresh = \"debug\" in request . args and settings . DEBUG content = utils . html . gallery ( urls , refresh = refresh ) return response . html ( content ) @app.get ( \"/test\" ) @doc.exclude ( True ) async def test ( request ): if not settings . DEBUG : return response . redirect ( \"/\" ) urls = await asyncio . to_thread ( helpers . get_test_images , request ) content = utils . html . gallery ( urls , refresh = True ) return response . html ( content ) @app.get ( \"/favicon.ico\" ) @doc.exclude ( True ) async def favicon ( request ): return await response . file ( \"app/static/favicon.ico\" ) @app.middleware ( \"response\" ) async def set_cache_control ( request , response ): if response . content_type : if \"image\" in response . content_type : response . headers [ \"Cache-Control\" ] = \"public, max-age=86400\" elif \"json\" in response . content_type : response . headers [ \"Cache-Control\" ] = \"public, max-age=3600\" if __name__ == \"__main__\" : log . reset () log . silence ( \"datafiles\" , allow_warning = True ) app . run ( host = \"0.0.0.0\" , port = settings . PORT , workers = settings . WORKERS , debug = settings . DEBUG , access_log = False , ) Variables app favicon index jinja samples test Functions set_cache_control def set_cache_control ( request , response ) View Source @app . middleware ( \"response\" ) async def set_cache_control ( request , response ) : if response . content_type : if \"image\" in response . content_type : response . headers [ \"Cache-Control\" ] = \"public, max-age=86400\" elif \"json\" in response . content_type : response . headers [ \"Cache-Control\" ] = \"public, max-age=3600\"","title":"Views"},{"location":"reference/app/views/#module-appviews","text":"View Source import asyncio from pathlib import Path import log from markdown import markdown from sanic import Sanic , response from sanic_jinja2 import SanicJinja2 from sanic_openapi import doc from app import helpers , settings , utils app = Sanic ( name = \"memegen\" ) helpers . configure ( app ) jinja = SanicJinja2 ( app , pkg_name = \"app\" ) @app.get ( \"/\" ) @doc.exclude ( True ) @jinja.template ( \"index.html\" ) async def index ( request ): html = markdown ( text = Path ( \"README.md\" ) . read_text (), extensions = [ \"markdown.extensions.tables\" ], ) html = html . replace ( \"<code></code>\" , \"<code>&nbsp</code>\" ) html = html . replace ( \"https://api.memegen.link\" , f \"{settings.SCHEME}://{settings.SERVER_NAME}\" , ) return { \"content\" : html } @app.get ( \"/samples\" ) @doc.exclude ( True ) async def samples ( request ): samples = await asyncio . to_thread ( helpers . get_sample_images , request ) urls = [ sample [ 0 ] for sample in samples ] refresh = \"debug\" in request . args and settings . DEBUG content = utils . html . gallery ( urls , refresh = refresh ) return response . html ( content ) @app.get ( \"/test\" ) @doc.exclude ( True ) async def test ( request ): if not settings . DEBUG : return response . redirect ( \"/\" ) urls = await asyncio . to_thread ( helpers . get_test_images , request ) content = utils . html . gallery ( urls , refresh = True ) return response . html ( content ) @app.get ( \"/favicon.ico\" ) @doc.exclude ( True ) async def favicon ( request ): return await response . file ( \"app/static/favicon.ico\" ) @app.middleware ( \"response\" ) async def set_cache_control ( request , response ): if response . content_type : if \"image\" in response . content_type : response . headers [ \"Cache-Control\" ] = \"public, max-age=86400\" elif \"json\" in response . content_type : response . headers [ \"Cache-Control\" ] = \"public, max-age=3600\" if __name__ == \"__main__\" : log . reset () log . silence ( \"datafiles\" , allow_warning = True ) app . run ( host = \"0.0.0.0\" , port = settings . PORT , workers = settings . WORKERS , debug = settings . DEBUG , access_log = False , )","title":"Module app.views"},{"location":"reference/app/views/#variables","text":"app favicon index jinja samples test","title":"Variables"},{"location":"reference/app/views/#functions","text":"","title":"Functions"},{"location":"reference/app/views/#set_cache_control","text":"def set_cache_control ( request , response ) View Source @app . middleware ( \"response\" ) async def set_cache_control ( request , response ) : if response . content_type : if \"image\" in response . content_type : response . headers [ \"Cache-Control\" ] = \"public, max-age=86400\" elif \"json\" in response . content_type : response . headers [ \"Cache-Control\" ] = \"public, max-age=3600\"","title":"set_cache_control"},{"location":"reference/app/api/","text":"Module app.api View Source from . import images , shortcuts , templates Sub-modules app.api.images app.api.shortcuts app.api.templates","title":"Index"},{"location":"reference/app/api/#module-appapi","text":"View Source from . import images , shortcuts , templates","title":"Module app.api"},{"location":"reference/app/api/#sub-modules","text":"app.api.images app.api.shortcuts app.api.templates","title":"Sub-modules"},{"location":"reference/app/api/images/","text":"Module app.api.images View Source import asyncio from contextlib import suppress from typing import List from sanic import Blueprint , response from sanic.log import logger from sanic_openapi import doc from .. import helpers , models , settings , utils blueprint = Blueprint ( \"images\" , url_prefix = \"/images\" ) @blueprint.get ( \"/\" ) @doc.summary ( \"List sample memes\" ) @doc.operation ( \"images.list\" ) @doc.produces ( doc . List ({ \"url\" : str , \"template\" : str }), description = \"Successfully returned a list of sample memes\" , content_type = \"application/json\" , ) async def index ( request ): samples = await asyncio . to_thread ( helpers . get_sample_images , request ) return response . json ( [{ \"url\" : url , \"template\" : template } for url , template in samples ] ) @blueprint.post ( \"/\" ) @doc.summary ( \"Create a meme from a template\" ) @doc.operation ( \"images.create\" ) @doc.consumes ( doc . JsonBody ( { \"template_key\" : str , \"text_lines\" : [ str ], \"extension\" : str , \"redirect\" : bool } ), content_type = \"application/json\" , location = \"body\" , ) @doc.response ( 201 , { \"url\" : str }, description = \"Successfully created a meme\" ) @doc.response ( 400 , { \"error\" : str }, description = 'Required \"template_key\" missing in request body' ) async def create ( request ): if request . form : payload = dict ( request . form ) with suppress ( KeyError ): payload [ \"template_key\" ] = payload . pop ( \"template_key\" )[ 0 ] with suppress ( KeyError ): payload [ \"text_lines\" ] = payload . pop ( \"text_lines[]\" ) else : payload = request . json try : template_key = payload [ \"template_key\" ] except KeyError : return response . json ({ \"error\" : '\"template_key\" is required' }, status = 400 ) template = models . Template . objects . get ( template_key ) url = template . build_custom_url ( request . app , payload . get ( \"text_lines\" ) or [], extension = payload . get ( \"extension\" ), ) if payload . get ( \"redirect\" , False ): return response . redirect ( url ) return response . json ({ \"url\" : url }, status = 201 ) @blueprint.get ( \"/preview.jpg\" ) @doc.summary ( \"Display a preview of a custom meme\" ) @doc.produces ( doc . File (), description = \"Successfully displayed a custom meme\" , content_type = \"image/jpeg\" , ) async def preview ( request ): key = request . args . get ( \"template\" , \"_error\" ) lines = request . args . getlist ( \"lines[]\" , []) style = request . args . get ( \"style\" ) return await preview_image ( request , key , lines , style ) @blueprint.get ( \"/<template_key>.png\" ) @doc.summary ( \"Display a template background\" ) @doc.produces ( doc . File (), description = \"Successfully displayed a template background\" , content_type = \"image/png\" , ) @doc.response ( 404 , doc . File (), description = \"Template not found\" ) @doc.response ( 415 , doc . File (), description = \"Unable to download image URL\" ) @doc.response ( 422 , doc . File (), description = \"Invalid style for template or no image URL specified for custom template\" , ) async def blank_png ( request , template_key ): return await render_image ( request , template_key , ext = \"png\" ) @blueprint.get ( \"/<template_key>.jpg\" ) @doc.summary ( \"Display a template background\" ) @doc.produces ( doc . File (), description = \"Successfully displayed a template background\" , content_type = \"image/jpeg\" , ) @doc.response ( 404 , doc . File (), description = \"Template not found\" ) @doc.response ( 415 , doc . File (), description = \"Unable to download image URL\" ) @doc.response ( 422 , doc . File (), description = \"Invalid style for template or no image URL specified for custom template\" , ) async def blank_jpg ( request , template_key ): return await render_image ( request , template_key , ext = \"jpg\" ) @blueprint.get ( \"/<template_key>/<text_paths:[\\s\\S]+>.png\" ) @doc.summary ( \"Display a custom meme\" ) @doc.produces ( doc . File (), description = \"Successfully displayed a custom meme\" , content_type = \"image/png\" , ) @doc.response ( 404 , doc . File (), description = \"Template not found\" ) @doc.response ( 414 , doc . File (), description = \"Custom text too long (length >200)\" ) @doc.response ( 415 , doc . File (), description = \"Unable to download image URL\" ) @doc.response ( 422 , doc . File (), description = \"Invalid style for template or no image URL specified for custom template\" , ) async def text_png ( request , template_key , text_paths ): slug , updated = utils . text . normalize ( text_paths ) if updated : url = request . app . url_for ( \"images.text_png\" , template_key = template_key , text_paths = slug , ** request . args , ) . replace ( \"%3A %2F%2F \" , \"://\" ) return response . redirect ( url , status = 301 ) return await render_image ( request , template_key , slug ) @blueprint.get ( \"/<template_key>/<text_paths:[\\s\\S]+>.jpg\" ) @doc.summary ( \"Display a custom meme\" ) @doc.produces ( doc . File (), description = \"Successfully displayed a custom meme\" , content_type = \"image/jpeg\" , ) @doc.response ( 404 , doc . File (), description = \"Template not found\" ) @doc.response ( 414 , doc . File (), description = \"Custom text too long (length >200)\" ) @doc.response ( 415 , doc . File (), description = \"Unable to download image URL\" ) @doc.response ( 422 , doc . File (), description = \"Invalid style for template or no image URL specified for custom template\" , ) async def text_jpg ( request , template_key , text_paths ): slug , updated = utils . text . normalize ( text_paths ) if updated : url = request . app . url_for ( \"images.text_jpg\" , template_key = template_key , text_paths = slug , ** request . args , ) . replace ( \"%3A %2F%2F \" , \"://\" ) return response . redirect ( url , status = 301 ) return await render_image ( request , template_key , slug , ext = \"jpg\" ) async def preview_image ( request , key : str , lines : List [ str ], style : str ): if \"://\" in key : template = await models . Template . create ( key ) else : template = models . Template . objects . get ( key ) data , content_type = await asyncio . to_thread ( utils . images . preview , template , lines , style ) return response . raw ( data , content_type = content_type ) async def render_image ( request , key : str , slug : str = \"\" , ext : str = settings . DEFAULT_EXT ): status = 200 if len ( slug . encode ()) > 200 : logger . error ( f \"Slug too long: {slug}\" ) slug = slug [: 50 ] + \"...\" template = models . Template . objects . get ( \"_error\" ) style = settings . DEFAULT_STYLE status = 414 elif key == \"custom\" : style = settings . DEFAULT_STYLE url = request . args . get ( \"background\" ) or request . args . get ( \"alt\" ) if url : template = await models . Template . create ( url ) if not template . image . exists (): logger . error ( f \"Unable to download image URL: {url}\" ) template = models . Template . objects . get ( \"_error\" ) status = 415 else : logger . error ( \"No image URL specified for custom template\" ) template = models . Template . objects . get ( \"_error\" ) status = 422 else : template = models . Template . objects . get_or_none ( key ) if not template : logger . error ( f \"No such template: {key}\" ) template = models . Template . objects . get ( \"_error\" ) status = 404 style = request . args . get ( \"style\" ) or request . args . get ( \"alt\" ) if style and style not in template . styles : logger . error ( f \"Invalid style for template: {style}\" ) status = 422 lines = utils . text . decode ( slug ) size = int ( request . args . get ( \"width\" , 0 )), int ( request . args . get ( \"height\" , 0 )) await helpers . track ( request , lines ) path = await asyncio . to_thread ( utils . images . save , template , lines , ext , style , size ) return await response . file ( path , status ) Variables blueprint Functions blank_jpg def blank_jpg ( request , template_key ) View Source @ blueprint . get ( \"/<template_key>.jpg\" ) @ doc . summary ( \"Display a template background\" ) @ doc . produces ( doc . File (), description = \"Successfully displayed a template background\" , content_type = \"image/jpeg\" , ) @ doc . response ( 404 , doc . File (), description = \"Template not found\" ) @ doc . response ( 415 , doc . File (), description = \"Unable to download image URL\" ) @ doc . response ( 422 , doc . File (), description = \"Invalid style for template or no image URL specified for custom template\" , ) async def blank_jpg ( request , template_key ): return await render_image ( request , template_key , ext = \"jpg\" ) blank_png def blank_png ( request , template_key ) View Source @ blueprint . get ( \"/<template_key>.png\" ) @ doc . summary ( \"Display a template background\" ) @ doc . produces ( doc . File (), description = \"Successfully displayed a template background\" , content_type = \"image/png\" , ) @ doc . response ( 404 , doc . File (), description = \"Template not found\" ) @ doc . response ( 415 , doc . File (), description = \"Unable to download image URL\" ) @ doc . response ( 422 , doc . File (), description = \"Invalid style for template or no image URL specified for custom template\" , ) async def blank_png ( request , template_key ): return await render_image ( request , template_key , ext = \"png\" ) create def create ( request ) View Source @blueprint . post ( \"/\" ) @doc . summary ( \"Create a meme from a template\" ) @doc . operation ( \"images.create\" ) @doc . consumes ( doc . JsonBody ( { \"template_key\" : str , \"text_lines\" : [ str ] , \"extension\" : str , \"redirect\" : bool } ), content_type = \"application/json\" , location = \"body\" , ) @doc . response ( 201 , { \"url\" : str } , description = \"Successfully created a meme\" ) @doc . response ( 400 , { \"error\" : str } , description = 'Required \"template_key\" missing in request body' ) async def create ( request ) : if request . form : payload = dict ( request . form ) with suppress ( KeyError ) : payload [ \"template_key\" ] = payload . pop ( \"template_key\" ) [ 0 ] with suppress ( KeyError ) : payload [ \"text_lines\" ] = payload . pop ( \"text_lines[]\" ) else : payload = request . json try : template_key = payload [ \"template_key\" ] except KeyError : return response . json ( { \"error\" : '\"template_key\" is required' } , status = 400 ) template = models . Template . objects . get ( template_key ) url = template . build_custom_url ( request . app , payload . get ( \"text_lines\" ) or [] , extension = payload . get ( \"extension\" ), ) if payload . get ( \"redirect\" , False ) : return response . redirect ( url ) return response . json ( { \"url\" : url } , status = 201 ) index def index ( request ) View Source @blueprint . get ( \"/\" ) @doc . summary ( \"List sample memes\" ) @doc . operation ( \"images.list\" ) @doc . produces ( doc . List ( { \"url\" : str , \"template\" : str } ), description = \"Successfully returned a list of sample memes\" , content_type = \"application/json\" , ) async def index ( request ) : samples = await asyncio . to_thread ( helpers . get_sample_images , request ) return response . json ( [ {\"url\": url, \"template\": template} for url, template in samples ] ) preview def preview ( request ) View Source @blueprint . get ( \"/preview.jpg\" ) @doc . summary ( \"Display a preview of a custom meme\" ) @doc . produces ( doc . File (), description = \"Successfully displayed a custom meme\" , content_type = \"image/jpeg\" , ) async def preview ( request ) : key = request . args . get ( \"template\" , \"_error\" ) lines = request . args . getlist ( \"lines[]\" , [] ) style = request . args . get ( \"style\" ) return await preview_image ( request , key , lines , style ) preview_image def preview_image ( request , key : str , lines : List [ str ], style : str ) View Source async def preview_image ( request , key : str , lines : List [ str ] , style : str ) : if \"://\" in key : template = await models . Template . create ( key ) else : template = models . Template . objects . get ( key ) data , content_type = await asyncio . to_thread ( utils . images . preview , template , lines , style ) return response . raw ( data , content_type = content_type ) render_image def render_image ( request , key : str , slug : str = '' , ext : str = 'png' ) View Source async def render_image ( request , key : str , slug : str = \"\" , ext : str = settings . DEFAULT_EXT ): status = 200 if len ( slug . encode ()) > 200 : logger . error ( f \"Slug too long: {slug}\" ) slug = slug [: 50 ] + \"...\" template = models . Template . objects . get ( \"_error\" ) style = settings . DEFAULT_STYLE status = 414 elif key == \"custom\" : style = settings . DEFAULT_STYLE url = request . args . get ( \"background\" ) or request . args . get ( \"alt\" ) if url : template = await models . Template . create ( url ) if not template . image . exists (): logger . error ( f \"Unable to download image URL: {url}\" ) template = models . Template . objects . get ( \"_error\" ) status = 415 else : logger . error ( \"No image URL specified for custom template\" ) template = models . Template . objects . get ( \"_error\" ) status = 422 else : template = models . Template . objects . get_or_none ( key ) if not template : logger . error ( f \"No such template: {key}\" ) template = models . Template . objects . get ( \"_error\" ) status = 404 style = request . args . get ( \"style\" ) or request . args . get ( \"alt\" ) if style and style not in template . styles : logger . error ( f \"Invalid style for template: {style}\" ) status = 422 lines = utils . text . decode ( slug ) size = int ( request . args . get ( \"width\" , 0 )), int ( request . args . get ( \"height\" , 0 )) await helpers . track ( request , lines ) path = await asyncio . to_thread ( utils . images . save , template , lines , ext , style , size ) return await response . file ( path , status ) text_jpg def text_jpg ( request , template_key , text_paths ) View Source @ blueprint . get ( \"/<template_key>/<text_paths:[\\s\\S]+>.jpg\" ) @ doc . summary ( \"Display a custom meme\" ) @ doc . produces ( doc . File (), description = \"Successfully displayed a custom meme\" , content_type = \"image/jpeg\" , ) @ doc . response ( 404 , doc . File (), description = \"Template not found\" ) @ doc . response ( 414 , doc . File (), description = \"Custom text too long (length >200)\" ) @ doc . response ( 415 , doc . File (), description = \"Unable to download image URL\" ) @ doc . response ( 422 , doc . File (), description = \"Invalid style for template or no image URL specified for custom template\" , ) async def text_jpg ( request , template_key , text_paths ): slug , updated = utils . text . normalize ( text_paths ) if updated : url = request . app . url_for ( \"images.text_jpg\" , template_key = template_key , text_paths = slug , ** request . args , ) . replace ( \"%3A %2F%2F \" , \"://\" ) return response . redirect ( url , status = 301 ) return await render_image ( request , template_key , slug , ext = \"jpg\" ) text_png def text_png ( request , template_key , text_paths ) View Source @ blueprint . get ( \"/<template_key>/<text_paths:[\\s\\S]+>.png\" ) @ doc . summary ( \"Display a custom meme\" ) @ doc . produces ( doc . File (), description = \"Successfully displayed a custom meme\" , content_type = \"image/png\" , ) @ doc . response ( 404 , doc . File (), description = \"Template not found\" ) @ doc . response ( 414 , doc . File (), description = \"Custom text too long (length >200)\" ) @ doc . response ( 415 , doc . File (), description = \"Unable to download image URL\" ) @ doc . response ( 422 , doc . File (), description = \"Invalid style for template or no image URL specified for custom template\" , ) async def text_png ( request , template_key , text_paths ): slug , updated = utils . text . normalize ( text_paths ) if updated : url = request . app . url_for ( \"images.text_png\" , template_key = template_key , text_paths = slug , ** request . args , ) . replace ( \"%3A %2F%2F \" , \"://\" ) return response . redirect ( url , status = 301 ) return await render_image ( request , template_key , slug )","title":"Images"},{"location":"reference/app/api/images/#module-appapiimages","text":"View Source import asyncio from contextlib import suppress from typing import List from sanic import Blueprint , response from sanic.log import logger from sanic_openapi import doc from .. import helpers , models , settings , utils blueprint = Blueprint ( \"images\" , url_prefix = \"/images\" ) @blueprint.get ( \"/\" ) @doc.summary ( \"List sample memes\" ) @doc.operation ( \"images.list\" ) @doc.produces ( doc . List ({ \"url\" : str , \"template\" : str }), description = \"Successfully returned a list of sample memes\" , content_type = \"application/json\" , ) async def index ( request ): samples = await asyncio . to_thread ( helpers . get_sample_images , request ) return response . json ( [{ \"url\" : url , \"template\" : template } for url , template in samples ] ) @blueprint.post ( \"/\" ) @doc.summary ( \"Create a meme from a template\" ) @doc.operation ( \"images.create\" ) @doc.consumes ( doc . JsonBody ( { \"template_key\" : str , \"text_lines\" : [ str ], \"extension\" : str , \"redirect\" : bool } ), content_type = \"application/json\" , location = \"body\" , ) @doc.response ( 201 , { \"url\" : str }, description = \"Successfully created a meme\" ) @doc.response ( 400 , { \"error\" : str }, description = 'Required \"template_key\" missing in request body' ) async def create ( request ): if request . form : payload = dict ( request . form ) with suppress ( KeyError ): payload [ \"template_key\" ] = payload . pop ( \"template_key\" )[ 0 ] with suppress ( KeyError ): payload [ \"text_lines\" ] = payload . pop ( \"text_lines[]\" ) else : payload = request . json try : template_key = payload [ \"template_key\" ] except KeyError : return response . json ({ \"error\" : '\"template_key\" is required' }, status = 400 ) template = models . Template . objects . get ( template_key ) url = template . build_custom_url ( request . app , payload . get ( \"text_lines\" ) or [], extension = payload . get ( \"extension\" ), ) if payload . get ( \"redirect\" , False ): return response . redirect ( url ) return response . json ({ \"url\" : url }, status = 201 ) @blueprint.get ( \"/preview.jpg\" ) @doc.summary ( \"Display a preview of a custom meme\" ) @doc.produces ( doc . File (), description = \"Successfully displayed a custom meme\" , content_type = \"image/jpeg\" , ) async def preview ( request ): key = request . args . get ( \"template\" , \"_error\" ) lines = request . args . getlist ( \"lines[]\" , []) style = request . args . get ( \"style\" ) return await preview_image ( request , key , lines , style ) @blueprint.get ( \"/<template_key>.png\" ) @doc.summary ( \"Display a template background\" ) @doc.produces ( doc . File (), description = \"Successfully displayed a template background\" , content_type = \"image/png\" , ) @doc.response ( 404 , doc . File (), description = \"Template not found\" ) @doc.response ( 415 , doc . File (), description = \"Unable to download image URL\" ) @doc.response ( 422 , doc . File (), description = \"Invalid style for template or no image URL specified for custom template\" , ) async def blank_png ( request , template_key ): return await render_image ( request , template_key , ext = \"png\" ) @blueprint.get ( \"/<template_key>.jpg\" ) @doc.summary ( \"Display a template background\" ) @doc.produces ( doc . File (), description = \"Successfully displayed a template background\" , content_type = \"image/jpeg\" , ) @doc.response ( 404 , doc . File (), description = \"Template not found\" ) @doc.response ( 415 , doc . File (), description = \"Unable to download image URL\" ) @doc.response ( 422 , doc . File (), description = \"Invalid style for template or no image URL specified for custom template\" , ) async def blank_jpg ( request , template_key ): return await render_image ( request , template_key , ext = \"jpg\" ) @blueprint.get ( \"/<template_key>/<text_paths:[\\s\\S]+>.png\" ) @doc.summary ( \"Display a custom meme\" ) @doc.produces ( doc . File (), description = \"Successfully displayed a custom meme\" , content_type = \"image/png\" , ) @doc.response ( 404 , doc . File (), description = \"Template not found\" ) @doc.response ( 414 , doc . File (), description = \"Custom text too long (length >200)\" ) @doc.response ( 415 , doc . File (), description = \"Unable to download image URL\" ) @doc.response ( 422 , doc . File (), description = \"Invalid style for template or no image URL specified for custom template\" , ) async def text_png ( request , template_key , text_paths ): slug , updated = utils . text . normalize ( text_paths ) if updated : url = request . app . url_for ( \"images.text_png\" , template_key = template_key , text_paths = slug , ** request . args , ) . replace ( \"%3A %2F%2F \" , \"://\" ) return response . redirect ( url , status = 301 ) return await render_image ( request , template_key , slug ) @blueprint.get ( \"/<template_key>/<text_paths:[\\s\\S]+>.jpg\" ) @doc.summary ( \"Display a custom meme\" ) @doc.produces ( doc . File (), description = \"Successfully displayed a custom meme\" , content_type = \"image/jpeg\" , ) @doc.response ( 404 , doc . File (), description = \"Template not found\" ) @doc.response ( 414 , doc . File (), description = \"Custom text too long (length >200)\" ) @doc.response ( 415 , doc . File (), description = \"Unable to download image URL\" ) @doc.response ( 422 , doc . File (), description = \"Invalid style for template or no image URL specified for custom template\" , ) async def text_jpg ( request , template_key , text_paths ): slug , updated = utils . text . normalize ( text_paths ) if updated : url = request . app . url_for ( \"images.text_jpg\" , template_key = template_key , text_paths = slug , ** request . args , ) . replace ( \"%3A %2F%2F \" , \"://\" ) return response . redirect ( url , status = 301 ) return await render_image ( request , template_key , slug , ext = \"jpg\" ) async def preview_image ( request , key : str , lines : List [ str ], style : str ): if \"://\" in key : template = await models . Template . create ( key ) else : template = models . Template . objects . get ( key ) data , content_type = await asyncio . to_thread ( utils . images . preview , template , lines , style ) return response . raw ( data , content_type = content_type ) async def render_image ( request , key : str , slug : str = \"\" , ext : str = settings . DEFAULT_EXT ): status = 200 if len ( slug . encode ()) > 200 : logger . error ( f \"Slug too long: {slug}\" ) slug = slug [: 50 ] + \"...\" template = models . Template . objects . get ( \"_error\" ) style = settings . DEFAULT_STYLE status = 414 elif key == \"custom\" : style = settings . DEFAULT_STYLE url = request . args . get ( \"background\" ) or request . args . get ( \"alt\" ) if url : template = await models . Template . create ( url ) if not template . image . exists (): logger . error ( f \"Unable to download image URL: {url}\" ) template = models . Template . objects . get ( \"_error\" ) status = 415 else : logger . error ( \"No image URL specified for custom template\" ) template = models . Template . objects . get ( \"_error\" ) status = 422 else : template = models . Template . objects . get_or_none ( key ) if not template : logger . error ( f \"No such template: {key}\" ) template = models . Template . objects . get ( \"_error\" ) status = 404 style = request . args . get ( \"style\" ) or request . args . get ( \"alt\" ) if style and style not in template . styles : logger . error ( f \"Invalid style for template: {style}\" ) status = 422 lines = utils . text . decode ( slug ) size = int ( request . args . get ( \"width\" , 0 )), int ( request . args . get ( \"height\" , 0 )) await helpers . track ( request , lines ) path = await asyncio . to_thread ( utils . images . save , template , lines , ext , style , size ) return await response . file ( path , status )","title":"Module app.api.images"},{"location":"reference/app/api/images/#variables","text":"blueprint","title":"Variables"},{"location":"reference/app/api/images/#functions","text":"","title":"Functions"},{"location":"reference/app/api/images/#blank_jpg","text":"def blank_jpg ( request , template_key ) View Source @ blueprint . get ( \"/<template_key>.jpg\" ) @ doc . summary ( \"Display a template background\" ) @ doc . produces ( doc . File (), description = \"Successfully displayed a template background\" , content_type = \"image/jpeg\" , ) @ doc . response ( 404 , doc . File (), description = \"Template not found\" ) @ doc . response ( 415 , doc . File (), description = \"Unable to download image URL\" ) @ doc . response ( 422 , doc . File (), description = \"Invalid style for template or no image URL specified for custom template\" , ) async def blank_jpg ( request , template_key ): return await render_image ( request , template_key , ext = \"jpg\" )","title":"blank_jpg"},{"location":"reference/app/api/images/#blank_png","text":"def blank_png ( request , template_key ) View Source @ blueprint . get ( \"/<template_key>.png\" ) @ doc . summary ( \"Display a template background\" ) @ doc . produces ( doc . File (), description = \"Successfully displayed a template background\" , content_type = \"image/png\" , ) @ doc . response ( 404 , doc . File (), description = \"Template not found\" ) @ doc . response ( 415 , doc . File (), description = \"Unable to download image URL\" ) @ doc . response ( 422 , doc . File (), description = \"Invalid style for template or no image URL specified for custom template\" , ) async def blank_png ( request , template_key ): return await render_image ( request , template_key , ext = \"png\" )","title":"blank_png"},{"location":"reference/app/api/images/#create","text":"def create ( request ) View Source @blueprint . post ( \"/\" ) @doc . summary ( \"Create a meme from a template\" ) @doc . operation ( \"images.create\" ) @doc . consumes ( doc . JsonBody ( { \"template_key\" : str , \"text_lines\" : [ str ] , \"extension\" : str , \"redirect\" : bool } ), content_type = \"application/json\" , location = \"body\" , ) @doc . response ( 201 , { \"url\" : str } , description = \"Successfully created a meme\" ) @doc . response ( 400 , { \"error\" : str } , description = 'Required \"template_key\" missing in request body' ) async def create ( request ) : if request . form : payload = dict ( request . form ) with suppress ( KeyError ) : payload [ \"template_key\" ] = payload . pop ( \"template_key\" ) [ 0 ] with suppress ( KeyError ) : payload [ \"text_lines\" ] = payload . pop ( \"text_lines[]\" ) else : payload = request . json try : template_key = payload [ \"template_key\" ] except KeyError : return response . json ( { \"error\" : '\"template_key\" is required' } , status = 400 ) template = models . Template . objects . get ( template_key ) url = template . build_custom_url ( request . app , payload . get ( \"text_lines\" ) or [] , extension = payload . get ( \"extension\" ), ) if payload . get ( \"redirect\" , False ) : return response . redirect ( url ) return response . json ( { \"url\" : url } , status = 201 )","title":"create"},{"location":"reference/app/api/images/#index","text":"def index ( request ) View Source @blueprint . get ( \"/\" ) @doc . summary ( \"List sample memes\" ) @doc . operation ( \"images.list\" ) @doc . produces ( doc . List ( { \"url\" : str , \"template\" : str } ), description = \"Successfully returned a list of sample memes\" , content_type = \"application/json\" , ) async def index ( request ) : samples = await asyncio . to_thread ( helpers . get_sample_images , request ) return response . json ( [ {\"url\": url, \"template\": template} for url, template in samples ] )","title":"index"},{"location":"reference/app/api/images/#preview","text":"def preview ( request ) View Source @blueprint . get ( \"/preview.jpg\" ) @doc . summary ( \"Display a preview of a custom meme\" ) @doc . produces ( doc . File (), description = \"Successfully displayed a custom meme\" , content_type = \"image/jpeg\" , ) async def preview ( request ) : key = request . args . get ( \"template\" , \"_error\" ) lines = request . args . getlist ( \"lines[]\" , [] ) style = request . args . get ( \"style\" ) return await preview_image ( request , key , lines , style )","title":"preview"},{"location":"reference/app/api/images/#preview_image","text":"def preview_image ( request , key : str , lines : List [ str ], style : str ) View Source async def preview_image ( request , key : str , lines : List [ str ] , style : str ) : if \"://\" in key : template = await models . Template . create ( key ) else : template = models . Template . objects . get ( key ) data , content_type = await asyncio . to_thread ( utils . images . preview , template , lines , style ) return response . raw ( data , content_type = content_type )","title":"preview_image"},{"location":"reference/app/api/images/#render_image","text":"def render_image ( request , key : str , slug : str = '' , ext : str = 'png' ) View Source async def render_image ( request , key : str , slug : str = \"\" , ext : str = settings . DEFAULT_EXT ): status = 200 if len ( slug . encode ()) > 200 : logger . error ( f \"Slug too long: {slug}\" ) slug = slug [: 50 ] + \"...\" template = models . Template . objects . get ( \"_error\" ) style = settings . DEFAULT_STYLE status = 414 elif key == \"custom\" : style = settings . DEFAULT_STYLE url = request . args . get ( \"background\" ) or request . args . get ( \"alt\" ) if url : template = await models . Template . create ( url ) if not template . image . exists (): logger . error ( f \"Unable to download image URL: {url}\" ) template = models . Template . objects . get ( \"_error\" ) status = 415 else : logger . error ( \"No image URL specified for custom template\" ) template = models . Template . objects . get ( \"_error\" ) status = 422 else : template = models . Template . objects . get_or_none ( key ) if not template : logger . error ( f \"No such template: {key}\" ) template = models . Template . objects . get ( \"_error\" ) status = 404 style = request . args . get ( \"style\" ) or request . args . get ( \"alt\" ) if style and style not in template . styles : logger . error ( f \"Invalid style for template: {style}\" ) status = 422 lines = utils . text . decode ( slug ) size = int ( request . args . get ( \"width\" , 0 )), int ( request . args . get ( \"height\" , 0 )) await helpers . track ( request , lines ) path = await asyncio . to_thread ( utils . images . save , template , lines , ext , style , size ) return await response . file ( path , status )","title":"render_image"},{"location":"reference/app/api/images/#text_jpg","text":"def text_jpg ( request , template_key , text_paths ) View Source @ blueprint . get ( \"/<template_key>/<text_paths:[\\s\\S]+>.jpg\" ) @ doc . summary ( \"Display a custom meme\" ) @ doc . produces ( doc . File (), description = \"Successfully displayed a custom meme\" , content_type = \"image/jpeg\" , ) @ doc . response ( 404 , doc . File (), description = \"Template not found\" ) @ doc . response ( 414 , doc . File (), description = \"Custom text too long (length >200)\" ) @ doc . response ( 415 , doc . File (), description = \"Unable to download image URL\" ) @ doc . response ( 422 , doc . File (), description = \"Invalid style for template or no image URL specified for custom template\" , ) async def text_jpg ( request , template_key , text_paths ): slug , updated = utils . text . normalize ( text_paths ) if updated : url = request . app . url_for ( \"images.text_jpg\" , template_key = template_key , text_paths = slug , ** request . args , ) . replace ( \"%3A %2F%2F \" , \"://\" ) return response . redirect ( url , status = 301 ) return await render_image ( request , template_key , slug , ext = \"jpg\" )","title":"text_jpg"},{"location":"reference/app/api/images/#text_png","text":"def text_png ( request , template_key , text_paths ) View Source @ blueprint . get ( \"/<template_key>/<text_paths:[\\s\\S]+>.png\" ) @ doc . summary ( \"Display a custom meme\" ) @ doc . produces ( doc . File (), description = \"Successfully displayed a custom meme\" , content_type = \"image/png\" , ) @ doc . response ( 404 , doc . File (), description = \"Template not found\" ) @ doc . response ( 414 , doc . File (), description = \"Custom text too long (length >200)\" ) @ doc . response ( 415 , doc . File (), description = \"Unable to download image URL\" ) @ doc . response ( 422 , doc . File (), description = \"Invalid style for template or no image URL specified for custom template\" , ) async def text_png ( request , template_key , text_paths ): slug , updated = utils . text . normalize ( text_paths ) if updated : url = request . app . url_for ( \"images.text_png\" , template_key = template_key , text_paths = slug , ** request . args , ) . replace ( \"%3A %2F%2F \" , \"://\" ) return response . redirect ( url , status = 301 ) return await render_image ( request , template_key , slug )","title":"text_png"},{"location":"reference/app/api/shortcuts/","text":"Module app.api.shortcuts View Source from sanic import Blueprint , response from sanic.exceptions import abort from sanic.log import logger from sanic_openapi import doc from .. import models , settings , utils blueprint = Blueprint ( \"shortcuts\" , url_prefix = \"/\" ) @blueprint.get ( \"/images/<template_key>\" ) @doc.summary ( \"Redirect to a sample image\" ) @doc.response ( 302 , doc . File (), description = \"Successfully redirected to a sample image\" ) @doc.response ( 404 , str , description = \"Template not found\" ) @doc.response ( 501 , str , description = \"Template not fully implemented\" ) async def sample ( request , template_key ): if settings . DEBUG : template = models . Template . objects . get_or_create ( template_key ) else : template = models . Template . objects . get_or_none ( template_key ) if template and template . valid : url = template . build_sample_url ( request . app , \"shortcuts.custom\" , external = False ) return response . redirect ( url ) if settings . DEBUG : message = f \"Template not fully implemented: {template}\" logger . warn ( message ) template . datafile . save () abort ( 501 , message ) abort ( 404 , f \"Template not found: {template_key}\" ) @blueprint.get ( \"/<template_key>.png\" ) @doc.summary ( \"Redirect to a sample image\" ) @doc.exclude ( settings . DEPLOYED ) @doc.response ( 302 , doc . File (), description = \"Successfully redirected to a sample image\" ) @doc.response ( 404 , str , description = \"Template not found\" ) async def sample_png ( request , template_key ): template = models . Template . objects . get_or_none ( template_key ) if template : url = template . build_sample_url ( request . app , external = False ) return response . redirect ( url ) abort ( 404 , f \"Template not found: {template_key}\" ) @blueprint.get ( \"/<template_key>.jpg\" ) @doc.summary ( \"Redirect to a sample image\" ) @doc.exclude ( settings . DEPLOYED ) @doc.response ( 302 , doc . File (), description = \"Successfully redirected to a sample image\" ) @doc.response ( 404 , str , description = \"Template not found\" ) async def sample_jpg ( request , template_key ): template = models . Template . objects . get_or_none ( template_key ) if template : url = template . build_sample_url ( request . app , \"images.text_jpg\" , external = False ) return response . redirect ( url ) abort ( 404 , f \"Template not found: {template_key}\" ) @blueprint.get ( \"/<template_key>\" ) @doc.summary ( \"Redirect to a sample image\" ) @doc.exclude ( settings . DEPLOYED ) @doc.response ( 302 , doc . File (), description = \"Successfully redirected to a sample image\" ) async def sample_legacy ( request , template_key ): return response . redirect ( f \"/images/{template_key}\" ) @blueprint.get ( \"/images/<template_key>/<text_paths:[\\s\\S]+>\" ) @doc.summary ( \"Redirect to a custom image\" ) @doc.produces ( str , description = \"Successfully displayed a custom meme\" , content_type = \"text/html\" , ) @doc.response ( 302 , doc . File (), description = \"Successfully redirected to a custom image\" ) async def custom ( request , template_key , text_paths ): if not settings . DEBUG : url = request . app . url_for ( f \"images.text_{settings.DEFAULT_EXT}\" , template_key = template_key , text_paths = text_paths , ) return response . redirect ( url ) template = models . Template . objects . get_or_create ( template_key ) template . datafile . save () url = f \"/images/{template_key}/{text_paths}.png\" content = utils . html . gallery ([ url ], refresh = True , rate = 1.0 ) return response . html ( content ) @blueprint.get ( \"/<template_key>/<text_paths:[\\s\\S]+>.png\" ) @doc.summary ( \"Redirect to a custom image\" ) @doc.exclude ( settings . DEPLOYED ) @doc.response ( 302 , doc . File (), description = \"Successfully redirected to a custom image\" ) @doc.response ( 404 , str , description = \"Template not found\" ) async def custom_png ( request , template_key , text_paths ): template = models . Template . objects . get_or_none ( template_key ) if template : url = request . app . url_for ( \"images.text_png\" , template_key = template_key , text_paths = text_paths ) return response . redirect ( url ) abort ( 404 , f \"Template not found: {template_key}\" ) @blueprint.get ( \"/<template_key>/<text_paths:[\\s\\S]+>.jpg\" ) @doc.summary ( \"Redirect to a custom image\" ) @doc.exclude ( settings . DEPLOYED ) @doc.response ( 302 , doc . File (), description = \"Successfully redirected to a custom image\" ) @doc.response ( 404 , str , description = \"Template not found\" ) async def custom_jpg ( request , template_key , text_paths ): template = models . Template . objects . get_or_none ( template_key ) if template : url = request . app . url_for ( \"images.text_jpg\" , template_key = template_key , text_paths = text_paths ) return response . redirect ( url ) abort ( 404 , f \"Template not found: {template_key}\" ) @blueprint.get ( \"/<template_key>/<text_paths:[\\s\\S]+>\" ) @doc.summary ( \"Redirect to a custom image\" ) @doc.exclude ( settings . DEPLOYED ) @doc.response ( 302 , doc . File (), description = \"Successfully redirected to a custom image\" ) async def custom_legacy ( request , template_key , text_paths ): return response . redirect ( f \"/images/{template_key}/{text_paths}\" ) Variables blueprint Functions custom def custom ( request , template_key , text_paths ) View Source @blueprint . get ( \"/images/<template_key>/<text_paths:[\\s\\S]+>\" ) @doc . summary ( \"Redirect to a custom image\" ) @doc . produces ( str , description = \"Successfully displayed a custom meme\" , content_type = \"text/html\" , ) @doc . response ( 302 , doc . File (), description = \"Successfully redirected to a custom image\" ) async def custom ( request , template_key , text_paths ) : if not settings . DEBUG : url = request . app . url_for ( f \"images.text_{settings.DEFAULT_EXT}\" , template_key = template_key , text_paths = text_paths , ) return response . redirect ( url ) template = models . Template . objects . get_or_create ( template_key ) template . datafile . save () url = f \"/images/{template_key}/{text_paths}.png\" content = utils . html . gallery ( [ url ] , refresh = True , rate = 1.0 ) return response . html ( content ) custom_jpg def custom_jpg ( request , template_key , text_paths ) View Source @blueprint . get ( \"/<template_key>/<text_paths:[\\s\\S]+>.jpg\" ) @doc . summary ( \"Redirect to a custom image\" ) @doc . exclude ( settings . DEPLOYED ) @doc . response ( 302 , doc . File (), description = \"Successfully redirected to a custom image\" ) @doc . response ( 404 , str , description = \"Template not found\" ) async def custom_jpg ( request , template_key , text_paths ) : template = models . Template . objects . get_or_none ( template_key ) if template : url = request . app . url_for ( \"images.text_jpg\" , template_key = template_key , text_paths = text_paths ) return response . redirect ( url ) abort ( 404 , f \"Template not found: {template_key}\" ) custom_legacy def custom_legacy ( request , template_key , text_paths ) View Source @blueprint . get ( \"/<template_key>/<text_paths:[\\s\\S]+>\" ) @doc . summary ( \"Redirect to a custom image\" ) @doc . exclude ( settings . DEPLOYED ) @doc . response ( 302 , doc . File (), description = \"Successfully redirected to a custom image\" ) async def custom_legacy ( request , template_key , text_paths ) : return response . redirect ( f \"/images/{template_key}/{text_paths}\" ) custom_png def custom_png ( request , template_key , text_paths ) View Source @blueprint . get ( \"/<template_key>/<text_paths:[\\s\\S]+>.png\" ) @doc . summary ( \"Redirect to a custom image\" ) @doc . exclude ( settings . DEPLOYED ) @doc . response ( 302 , doc . File (), description = \"Successfully redirected to a custom image\" ) @doc . response ( 404 , str , description = \"Template not found\" ) async def custom_png ( request , template_key , text_paths ) : template = models . Template . objects . get_or_none ( template_key ) if template : url = request . app . url_for ( \"images.text_png\" , template_key = template_key , text_paths = text_paths ) return response . redirect ( url ) abort ( 404 , f \"Template not found: {template_key}\" ) sample def sample ( request , template_key ) View Source @blueprint . get ( \"/images/<template_key>\" ) @doc . summary ( \"Redirect to a sample image\" ) @doc . response ( 302 , doc . File (), description = \"Successfully redirected to a sample image\" ) @doc . response ( 404 , str , description = \"Template not found\" ) @doc . response ( 501 , str , description = \"Template not fully implemented\" ) async def sample ( request , template_key ) : if settings . DEBUG : template = models . Template . objects . get_or_create ( template_key ) else : template = models . Template . objects . get_or_none ( template_key ) if template and template . valid : url = template . build_sample_url ( request . app , \"shortcuts.custom\" , external = False ) return response . redirect ( url ) if settings . DEBUG : message = f \"Template not fully implemented: {template}\" logger . warn ( message ) template . datafile . save () abort ( 501 , message ) abort ( 404 , f \"Template not found: {template_key}\" ) sample_jpg def sample_jpg ( request , template_key ) View Source @blueprint . get ( \"/<template_key>.jpg\" ) @doc . summary ( \"Redirect to a sample image\" ) @doc . exclude ( settings . DEPLOYED ) @doc . response ( 302 , doc . File (), description = \"Successfully redirected to a sample image\" ) @doc . response ( 404 , str , description = \"Template not found\" ) async def sample_jpg ( request , template_key ) : template = models . Template . objects . get_or_none ( template_key ) if template : url = template . build_sample_url ( request . app , \"images.text_jpg\" , external = False ) return response . redirect ( url ) abort ( 404 , f \"Template not found: {template_key}\" ) sample_legacy def sample_legacy ( request , template_key ) View Source @blueprint . get ( \"/<template_key>\" ) @doc . summary ( \"Redirect to a sample image\" ) @doc . exclude ( settings . DEPLOYED ) @doc . response ( 302 , doc . File (), description = \"Successfully redirected to a sample image\" ) async def sample_legacy ( request , template_key ) : return response . redirect ( f \"/images/{template_key}\" ) sample_png def sample_png ( request , template_key ) View Source @blueprint . get ( \"/<template_key>.png\" ) @doc . summary ( \"Redirect to a sample image\" ) @doc . exclude ( settings . DEPLOYED ) @doc . response ( 302 , doc . File (), description = \"Successfully redirected to a sample image\" ) @doc . response ( 404 , str , description = \"Template not found\" ) async def sample_png ( request , template_key ) : template = models . Template . objects . get_or_none ( template_key ) if template : url = template . build_sample_url ( request . app , external = False ) return response . redirect ( url ) abort ( 404 , f \"Template not found: {template_key}\" )","title":"Shortcuts"},{"location":"reference/app/api/shortcuts/#module-appapishortcuts","text":"View Source from sanic import Blueprint , response from sanic.exceptions import abort from sanic.log import logger from sanic_openapi import doc from .. import models , settings , utils blueprint = Blueprint ( \"shortcuts\" , url_prefix = \"/\" ) @blueprint.get ( \"/images/<template_key>\" ) @doc.summary ( \"Redirect to a sample image\" ) @doc.response ( 302 , doc . File (), description = \"Successfully redirected to a sample image\" ) @doc.response ( 404 , str , description = \"Template not found\" ) @doc.response ( 501 , str , description = \"Template not fully implemented\" ) async def sample ( request , template_key ): if settings . DEBUG : template = models . Template . objects . get_or_create ( template_key ) else : template = models . Template . objects . get_or_none ( template_key ) if template and template . valid : url = template . build_sample_url ( request . app , \"shortcuts.custom\" , external = False ) return response . redirect ( url ) if settings . DEBUG : message = f \"Template not fully implemented: {template}\" logger . warn ( message ) template . datafile . save () abort ( 501 , message ) abort ( 404 , f \"Template not found: {template_key}\" ) @blueprint.get ( \"/<template_key>.png\" ) @doc.summary ( \"Redirect to a sample image\" ) @doc.exclude ( settings . DEPLOYED ) @doc.response ( 302 , doc . File (), description = \"Successfully redirected to a sample image\" ) @doc.response ( 404 , str , description = \"Template not found\" ) async def sample_png ( request , template_key ): template = models . Template . objects . get_or_none ( template_key ) if template : url = template . build_sample_url ( request . app , external = False ) return response . redirect ( url ) abort ( 404 , f \"Template not found: {template_key}\" ) @blueprint.get ( \"/<template_key>.jpg\" ) @doc.summary ( \"Redirect to a sample image\" ) @doc.exclude ( settings . DEPLOYED ) @doc.response ( 302 , doc . File (), description = \"Successfully redirected to a sample image\" ) @doc.response ( 404 , str , description = \"Template not found\" ) async def sample_jpg ( request , template_key ): template = models . Template . objects . get_or_none ( template_key ) if template : url = template . build_sample_url ( request . app , \"images.text_jpg\" , external = False ) return response . redirect ( url ) abort ( 404 , f \"Template not found: {template_key}\" ) @blueprint.get ( \"/<template_key>\" ) @doc.summary ( \"Redirect to a sample image\" ) @doc.exclude ( settings . DEPLOYED ) @doc.response ( 302 , doc . File (), description = \"Successfully redirected to a sample image\" ) async def sample_legacy ( request , template_key ): return response . redirect ( f \"/images/{template_key}\" ) @blueprint.get ( \"/images/<template_key>/<text_paths:[\\s\\S]+>\" ) @doc.summary ( \"Redirect to a custom image\" ) @doc.produces ( str , description = \"Successfully displayed a custom meme\" , content_type = \"text/html\" , ) @doc.response ( 302 , doc . File (), description = \"Successfully redirected to a custom image\" ) async def custom ( request , template_key , text_paths ): if not settings . DEBUG : url = request . app . url_for ( f \"images.text_{settings.DEFAULT_EXT}\" , template_key = template_key , text_paths = text_paths , ) return response . redirect ( url ) template = models . Template . objects . get_or_create ( template_key ) template . datafile . save () url = f \"/images/{template_key}/{text_paths}.png\" content = utils . html . gallery ([ url ], refresh = True , rate = 1.0 ) return response . html ( content ) @blueprint.get ( \"/<template_key>/<text_paths:[\\s\\S]+>.png\" ) @doc.summary ( \"Redirect to a custom image\" ) @doc.exclude ( settings . DEPLOYED ) @doc.response ( 302 , doc . File (), description = \"Successfully redirected to a custom image\" ) @doc.response ( 404 , str , description = \"Template not found\" ) async def custom_png ( request , template_key , text_paths ): template = models . Template . objects . get_or_none ( template_key ) if template : url = request . app . url_for ( \"images.text_png\" , template_key = template_key , text_paths = text_paths ) return response . redirect ( url ) abort ( 404 , f \"Template not found: {template_key}\" ) @blueprint.get ( \"/<template_key>/<text_paths:[\\s\\S]+>.jpg\" ) @doc.summary ( \"Redirect to a custom image\" ) @doc.exclude ( settings . DEPLOYED ) @doc.response ( 302 , doc . File (), description = \"Successfully redirected to a custom image\" ) @doc.response ( 404 , str , description = \"Template not found\" ) async def custom_jpg ( request , template_key , text_paths ): template = models . Template . objects . get_or_none ( template_key ) if template : url = request . app . url_for ( \"images.text_jpg\" , template_key = template_key , text_paths = text_paths ) return response . redirect ( url ) abort ( 404 , f \"Template not found: {template_key}\" ) @blueprint.get ( \"/<template_key>/<text_paths:[\\s\\S]+>\" ) @doc.summary ( \"Redirect to a custom image\" ) @doc.exclude ( settings . DEPLOYED ) @doc.response ( 302 , doc . File (), description = \"Successfully redirected to a custom image\" ) async def custom_legacy ( request , template_key , text_paths ): return response . redirect ( f \"/images/{template_key}/{text_paths}\" )","title":"Module app.api.shortcuts"},{"location":"reference/app/api/shortcuts/#variables","text":"blueprint","title":"Variables"},{"location":"reference/app/api/shortcuts/#functions","text":"","title":"Functions"},{"location":"reference/app/api/shortcuts/#custom","text":"def custom ( request , template_key , text_paths ) View Source @blueprint . get ( \"/images/<template_key>/<text_paths:[\\s\\S]+>\" ) @doc . summary ( \"Redirect to a custom image\" ) @doc . produces ( str , description = \"Successfully displayed a custom meme\" , content_type = \"text/html\" , ) @doc . response ( 302 , doc . File (), description = \"Successfully redirected to a custom image\" ) async def custom ( request , template_key , text_paths ) : if not settings . DEBUG : url = request . app . url_for ( f \"images.text_{settings.DEFAULT_EXT}\" , template_key = template_key , text_paths = text_paths , ) return response . redirect ( url ) template = models . Template . objects . get_or_create ( template_key ) template . datafile . save () url = f \"/images/{template_key}/{text_paths}.png\" content = utils . html . gallery ( [ url ] , refresh = True , rate = 1.0 ) return response . html ( content )","title":"custom"},{"location":"reference/app/api/shortcuts/#custom_jpg","text":"def custom_jpg ( request , template_key , text_paths ) View Source @blueprint . get ( \"/<template_key>/<text_paths:[\\s\\S]+>.jpg\" ) @doc . summary ( \"Redirect to a custom image\" ) @doc . exclude ( settings . DEPLOYED ) @doc . response ( 302 , doc . File (), description = \"Successfully redirected to a custom image\" ) @doc . response ( 404 , str , description = \"Template not found\" ) async def custom_jpg ( request , template_key , text_paths ) : template = models . Template . objects . get_or_none ( template_key ) if template : url = request . app . url_for ( \"images.text_jpg\" , template_key = template_key , text_paths = text_paths ) return response . redirect ( url ) abort ( 404 , f \"Template not found: {template_key}\" )","title":"custom_jpg"},{"location":"reference/app/api/shortcuts/#custom_legacy","text":"def custom_legacy ( request , template_key , text_paths ) View Source @blueprint . get ( \"/<template_key>/<text_paths:[\\s\\S]+>\" ) @doc . summary ( \"Redirect to a custom image\" ) @doc . exclude ( settings . DEPLOYED ) @doc . response ( 302 , doc . File (), description = \"Successfully redirected to a custom image\" ) async def custom_legacy ( request , template_key , text_paths ) : return response . redirect ( f \"/images/{template_key}/{text_paths}\" )","title":"custom_legacy"},{"location":"reference/app/api/shortcuts/#custom_png","text":"def custom_png ( request , template_key , text_paths ) View Source @blueprint . get ( \"/<template_key>/<text_paths:[\\s\\S]+>.png\" ) @doc . summary ( \"Redirect to a custom image\" ) @doc . exclude ( settings . DEPLOYED ) @doc . response ( 302 , doc . File (), description = \"Successfully redirected to a custom image\" ) @doc . response ( 404 , str , description = \"Template not found\" ) async def custom_png ( request , template_key , text_paths ) : template = models . Template . objects . get_or_none ( template_key ) if template : url = request . app . url_for ( \"images.text_png\" , template_key = template_key , text_paths = text_paths ) return response . redirect ( url ) abort ( 404 , f \"Template not found: {template_key}\" )","title":"custom_png"},{"location":"reference/app/api/shortcuts/#sample","text":"def sample ( request , template_key ) View Source @blueprint . get ( \"/images/<template_key>\" ) @doc . summary ( \"Redirect to a sample image\" ) @doc . response ( 302 , doc . File (), description = \"Successfully redirected to a sample image\" ) @doc . response ( 404 , str , description = \"Template not found\" ) @doc . response ( 501 , str , description = \"Template not fully implemented\" ) async def sample ( request , template_key ) : if settings . DEBUG : template = models . Template . objects . get_or_create ( template_key ) else : template = models . Template . objects . get_or_none ( template_key ) if template and template . valid : url = template . build_sample_url ( request . app , \"shortcuts.custom\" , external = False ) return response . redirect ( url ) if settings . DEBUG : message = f \"Template not fully implemented: {template}\" logger . warn ( message ) template . datafile . save () abort ( 501 , message ) abort ( 404 , f \"Template not found: {template_key}\" )","title":"sample"},{"location":"reference/app/api/shortcuts/#sample_jpg","text":"def sample_jpg ( request , template_key ) View Source @blueprint . get ( \"/<template_key>.jpg\" ) @doc . summary ( \"Redirect to a sample image\" ) @doc . exclude ( settings . DEPLOYED ) @doc . response ( 302 , doc . File (), description = \"Successfully redirected to a sample image\" ) @doc . response ( 404 , str , description = \"Template not found\" ) async def sample_jpg ( request , template_key ) : template = models . Template . objects . get_or_none ( template_key ) if template : url = template . build_sample_url ( request . app , \"images.text_jpg\" , external = False ) return response . redirect ( url ) abort ( 404 , f \"Template not found: {template_key}\" )","title":"sample_jpg"},{"location":"reference/app/api/shortcuts/#sample_legacy","text":"def sample_legacy ( request , template_key ) View Source @blueprint . get ( \"/<template_key>\" ) @doc . summary ( \"Redirect to a sample image\" ) @doc . exclude ( settings . DEPLOYED ) @doc . response ( 302 , doc . File (), description = \"Successfully redirected to a sample image\" ) async def sample_legacy ( request , template_key ) : return response . redirect ( f \"/images/{template_key}\" )","title":"sample_legacy"},{"location":"reference/app/api/shortcuts/#sample_png","text":"def sample_png ( request , template_key ) View Source @blueprint . get ( \"/<template_key>.png\" ) @doc . summary ( \"Redirect to a sample image\" ) @doc . exclude ( settings . DEPLOYED ) @doc . response ( 302 , doc . File (), description = \"Successfully redirected to a sample image\" ) @doc . response ( 404 , str , description = \"Template not found\" ) async def sample_png ( request , template_key ) : template = models . Template . objects . get_or_none ( template_key ) if template : url = template . build_sample_url ( request . app , external = False ) return response . redirect ( url ) abort ( 404 , f \"Template not found: {template_key}\" )","title":"sample_png"},{"location":"reference/app/api/templates/","text":"Module app.api.templates View Source import asyncio from contextlib import suppress from sanic import Blueprint , response from sanic.exceptions import abort from sanic_openapi import doc from .. import helpers from ..models import Template blueprint = Blueprint ( \"templates\" , url_prefix = \"/templates\" ) @blueprint.get ( \"/\" ) @doc.summary ( \"List all templates\" ) @doc.produces ( # Can't use doc.List(Template) because the jsonify method is slightly different doc . List ( { \"name\" : str , \"key\" : str , \"styles\" : doc . List ( str ), \"blank\" : str , \"sample\" : str , \"source\" : str , \"_self\" : str , } ), description = \"Successfully returned a list of all templates\" , content_type = \"application/json\" , ) async def index ( request ): data = await asyncio . to_thread ( helpers . get_valid_templates , request ) return response . json ( data ) @blueprint.get ( \"/<key>\" ) @doc.summary ( \"View a specific template\" ) @doc.operation ( \"templates.detail\" ) @doc.produces ( { \"name\" : str , \"key\" : str , \"styles\" : doc . List ( str ), \"blank\" : str , \"sample\" : str , \"source\" : str , \"_self\" : str , }, description = \"Successfully returned a specific templates\" , content_type = \"application/json\" , ) @doc.response ( 404 , str , description = \"Template not found\" ) async def detail ( request , key ): template = Template . objects . get_or_none ( key ) if template : return response . json ( template . jsonify ( request . app )) abort ( 404 ) @blueprint.post ( \"/custom\" ) @doc.summary ( \"Create a meme from any image\" ) @doc.consumes ( doc . JsonBody ( { \"image_url\" : str , \"text_lines\" : [ str ], \"extension\" : str , \"redirect\" : bool } ), content_type = \"application/json\" , location = \"body\" , ) @doc.response ( 201 , { \"url\" : str }, description = \"Successfully created a meme from a custom image\" ) async def custom ( request ): if request . form : payload = dict ( request . form ) with suppress ( KeyError ): payload [ \"text_lines\" ] = payload . pop ( \"text_lines[]\" ) else : payload = request . json url = Template ( \"_custom\" ) . build_custom_url ( request . app , payload . get ( \"text_lines\" ) or [], background = payload . get ( \"image_url\" , \"\" ), extension = payload . get ( \"extension\" , \"\" ), ) if payload . get ( \"redirect\" , False ): return response . redirect ( url ) return response . json ({ \"url\" : url }, status = 201 ) @blueprint.post ( \"/<key>\" ) @doc.summary ( \"Create a meme from a template\" ) @doc.operation ( \"templates.create\" ) @doc.consumes ( doc . JsonBody ({ \"text_lines\" : [ str ], \"extension\" : str , \"redirect\" : bool }), content_type = \"application/json\" , location = \"body\" , ) @doc.response ( 201 , { \"url\" : str }, description = \"Successfully created a meme from a template\" ) async def build ( request , key ): if request . form : payload = dict ( request . form ) with suppress ( KeyError ): payload [ \"text_lines\" ] = payload . pop ( \"text_lines[]\" ) else : payload = request . json template = Template . objects . get ( key ) url = template . build_custom_url ( request . app , payload . get ( \"text_lines\" ) or [], extension = payload . get ( \"extension\" ), ) if payload . get ( \"redirect\" , False ): return response . redirect ( url ) return response . json ({ \"url\" : url }, status = 201 ) Variables blueprint Functions build def build ( request , key ) View Source @blueprint . post ( \"/<key>\" ) @doc . summary ( \"Create a meme from a template\" ) @doc . operation ( \"templates.create\" ) @doc . consumes ( doc . JsonBody ( { \"text_lines\" : [ str ] , \"extension\" : str , \"redirect\" : bool } ), content_type = \"application/json\" , location = \"body\" , ) @doc . response ( 201 , { \"url\" : str } , description = \"Successfully created a meme from a template\" ) async def build ( request , key ) : if request . form : payload = dict ( request . form ) with suppress ( KeyError ) : payload [ \"text_lines\" ] = payload . pop ( \"text_lines[]\" ) else : payload = request . json template = Template . objects . get ( key ) url = template . build_custom_url ( request . app , payload . get ( \"text_lines\" ) or [] , extension = payload . get ( \"extension\" ), ) if payload . get ( \"redirect\" , False ) : return response . redirect ( url ) return response . json ( { \"url\" : url } , status = 201 ) custom def custom ( request ) View Source @blueprint . post ( \"/custom\" ) @doc . summary ( \"Create a meme from any image\" ) @doc . consumes ( doc . JsonBody ( { \"image_url\" : str , \"text_lines\" : [ str ] , \"extension\" : str , \"redirect\" : bool } ), content_type = \"application/json\" , location = \"body\" , ) @doc . response ( 201 , { \"url\" : str } , description = \"Successfully created a meme from a custom image\" ) async def custom ( request ) : if request . form : payload = dict ( request . form ) with suppress ( KeyError ) : payload [ \"text_lines\" ] = payload . pop ( \"text_lines[]\" ) else : payload = request . json url = Template ( \"_custom\" ). build_custom_url ( request . app , payload . get ( \"text_lines\" ) or [] , background = payload . get ( \"image_url\" , \"\" ), extension = payload . get ( \"extension\" , \"\" ), ) if payload . get ( \"redirect\" , False ) : return response . redirect ( url ) return response . json ( { \"url\" : url } , status = 201 ) detail def detail ( request , key ) View Source @blueprint . get ( \"/<key>\" ) @doc . summary ( \"View a specific template\" ) @doc . operation ( \"templates.detail\" ) @doc . produces ( { \"name\" : str , \"key\" : str , \"styles\" : doc . List ( str ), \"blank\" : str , \"sample\" : str , \"source\" : str , \"_self\" : str , } , description = \"Successfully returned a specific templates\" , content_type = \"application/json\" , ) @doc . response ( 404 , str , description = \"Template not found\" ) async def detail ( request , key ) : template = Template . objects . get_or_none ( key ) if template : return response . json ( template . jsonify ( request . app )) abort ( 404 ) index def index ( request ) View Source @blueprint . get ( \"/\" ) @doc . summary ( \"List all templates\" ) @doc . produces ( # Can ' t use doc . List ( Template ) because the jsonify method is slightly different doc . List ( { \"name\" : str , \"key\" : str , \"styles\" : doc . List ( str ), \"blank\" : str , \"sample\" : str , \"source\" : str , \"_self\" : str , } ), description = \"Successfully returned a list of all templates\" , content_type = \"application/json\" , ) async def index ( request ) : data = await asyncio . to_thread ( helpers . get_valid_templates , request ) return response . json ( data )","title":"Templates"},{"location":"reference/app/api/templates/#module-appapitemplates","text":"View Source import asyncio from contextlib import suppress from sanic import Blueprint , response from sanic.exceptions import abort from sanic_openapi import doc from .. import helpers from ..models import Template blueprint = Blueprint ( \"templates\" , url_prefix = \"/templates\" ) @blueprint.get ( \"/\" ) @doc.summary ( \"List all templates\" ) @doc.produces ( # Can't use doc.List(Template) because the jsonify method is slightly different doc . List ( { \"name\" : str , \"key\" : str , \"styles\" : doc . List ( str ), \"blank\" : str , \"sample\" : str , \"source\" : str , \"_self\" : str , } ), description = \"Successfully returned a list of all templates\" , content_type = \"application/json\" , ) async def index ( request ): data = await asyncio . to_thread ( helpers . get_valid_templates , request ) return response . json ( data ) @blueprint.get ( \"/<key>\" ) @doc.summary ( \"View a specific template\" ) @doc.operation ( \"templates.detail\" ) @doc.produces ( { \"name\" : str , \"key\" : str , \"styles\" : doc . List ( str ), \"blank\" : str , \"sample\" : str , \"source\" : str , \"_self\" : str , }, description = \"Successfully returned a specific templates\" , content_type = \"application/json\" , ) @doc.response ( 404 , str , description = \"Template not found\" ) async def detail ( request , key ): template = Template . objects . get_or_none ( key ) if template : return response . json ( template . jsonify ( request . app )) abort ( 404 ) @blueprint.post ( \"/custom\" ) @doc.summary ( \"Create a meme from any image\" ) @doc.consumes ( doc . JsonBody ( { \"image_url\" : str , \"text_lines\" : [ str ], \"extension\" : str , \"redirect\" : bool } ), content_type = \"application/json\" , location = \"body\" , ) @doc.response ( 201 , { \"url\" : str }, description = \"Successfully created a meme from a custom image\" ) async def custom ( request ): if request . form : payload = dict ( request . form ) with suppress ( KeyError ): payload [ \"text_lines\" ] = payload . pop ( \"text_lines[]\" ) else : payload = request . json url = Template ( \"_custom\" ) . build_custom_url ( request . app , payload . get ( \"text_lines\" ) or [], background = payload . get ( \"image_url\" , \"\" ), extension = payload . get ( \"extension\" , \"\" ), ) if payload . get ( \"redirect\" , False ): return response . redirect ( url ) return response . json ({ \"url\" : url }, status = 201 ) @blueprint.post ( \"/<key>\" ) @doc.summary ( \"Create a meme from a template\" ) @doc.operation ( \"templates.create\" ) @doc.consumes ( doc . JsonBody ({ \"text_lines\" : [ str ], \"extension\" : str , \"redirect\" : bool }), content_type = \"application/json\" , location = \"body\" , ) @doc.response ( 201 , { \"url\" : str }, description = \"Successfully created a meme from a template\" ) async def build ( request , key ): if request . form : payload = dict ( request . form ) with suppress ( KeyError ): payload [ \"text_lines\" ] = payload . pop ( \"text_lines[]\" ) else : payload = request . json template = Template . objects . get ( key ) url = template . build_custom_url ( request . app , payload . get ( \"text_lines\" ) or [], extension = payload . get ( \"extension\" ), ) if payload . get ( \"redirect\" , False ): return response . redirect ( url ) return response . json ({ \"url\" : url }, status = 201 )","title":"Module app.api.templates"},{"location":"reference/app/api/templates/#variables","text":"blueprint","title":"Variables"},{"location":"reference/app/api/templates/#functions","text":"","title":"Functions"},{"location":"reference/app/api/templates/#build","text":"def build ( request , key ) View Source @blueprint . post ( \"/<key>\" ) @doc . summary ( \"Create a meme from a template\" ) @doc . operation ( \"templates.create\" ) @doc . consumes ( doc . JsonBody ( { \"text_lines\" : [ str ] , \"extension\" : str , \"redirect\" : bool } ), content_type = \"application/json\" , location = \"body\" , ) @doc . response ( 201 , { \"url\" : str } , description = \"Successfully created a meme from a template\" ) async def build ( request , key ) : if request . form : payload = dict ( request . form ) with suppress ( KeyError ) : payload [ \"text_lines\" ] = payload . pop ( \"text_lines[]\" ) else : payload = request . json template = Template . objects . get ( key ) url = template . build_custom_url ( request . app , payload . get ( \"text_lines\" ) or [] , extension = payload . get ( \"extension\" ), ) if payload . get ( \"redirect\" , False ) : return response . redirect ( url ) return response . json ( { \"url\" : url } , status = 201 )","title":"build"},{"location":"reference/app/api/templates/#custom","text":"def custom ( request ) View Source @blueprint . post ( \"/custom\" ) @doc . summary ( \"Create a meme from any image\" ) @doc . consumes ( doc . JsonBody ( { \"image_url\" : str , \"text_lines\" : [ str ] , \"extension\" : str , \"redirect\" : bool } ), content_type = \"application/json\" , location = \"body\" , ) @doc . response ( 201 , { \"url\" : str } , description = \"Successfully created a meme from a custom image\" ) async def custom ( request ) : if request . form : payload = dict ( request . form ) with suppress ( KeyError ) : payload [ \"text_lines\" ] = payload . pop ( \"text_lines[]\" ) else : payload = request . json url = Template ( \"_custom\" ). build_custom_url ( request . app , payload . get ( \"text_lines\" ) or [] , background = payload . get ( \"image_url\" , \"\" ), extension = payload . get ( \"extension\" , \"\" ), ) if payload . get ( \"redirect\" , False ) : return response . redirect ( url ) return response . json ( { \"url\" : url } , status = 201 )","title":"custom"},{"location":"reference/app/api/templates/#detail","text":"def detail ( request , key ) View Source @blueprint . get ( \"/<key>\" ) @doc . summary ( \"View a specific template\" ) @doc . operation ( \"templates.detail\" ) @doc . produces ( { \"name\" : str , \"key\" : str , \"styles\" : doc . List ( str ), \"blank\" : str , \"sample\" : str , \"source\" : str , \"_self\" : str , } , description = \"Successfully returned a specific templates\" , content_type = \"application/json\" , ) @doc . response ( 404 , str , description = \"Template not found\" ) async def detail ( request , key ) : template = Template . objects . get_or_none ( key ) if template : return response . json ( template . jsonify ( request . app )) abort ( 404 )","title":"detail"},{"location":"reference/app/api/templates/#index","text":"def index ( request ) View Source @blueprint . get ( \"/\" ) @doc . summary ( \"List all templates\" ) @doc . produces ( # Can ' t use doc . List ( Template ) because the jsonify method is slightly different doc . List ( { \"name\" : str , \"key\" : str , \"styles\" : doc . List ( str ), \"blank\" : str , \"sample\" : str , \"source\" : str , \"_self\" : str , } ), description = \"Successfully returned a list of all templates\" , content_type = \"application/json\" , ) async def index ( request ) : data = await asyncio . to_thread ( helpers . get_valid_templates , request ) return response . json ( data )","title":"index"},{"location":"reference/app/tests/","text":"Module app.tests Sub-modules app.tests.conftest app.tests.test_apis app.tests.test_docs app.tests.test_images app.tests.test_models app.tests.test_text app.tests.test_views","title":"Index"},{"location":"reference/app/tests/#module-apptests","text":"","title":"Module app.tests"},{"location":"reference/app/tests/#sub-modules","text":"app.tests.conftest app.tests.test_apis app.tests.test_docs app.tests.test_images app.tests.test_models app.tests.test_text app.tests.test_views","title":"Sub-modules"},{"location":"reference/app/tests/conftest/","text":"Module app.tests.conftest View Source import os import pytest from app.views import app def pytest_configure ( config ): terminal = config . pluginmanager . getplugin ( \"terminal\" ) terminal . TerminalReporter . showfspath = False def pytest_runtest_setup ( item ): for marker in item . iter_markers ( name = \"slow\" ): if \"SKIP_SLOW\" in os . environ : pytest . skip ( \"slow test\" ) @pytest.fixture def client (): return app . test_client Functions client def client ( ) View Source @pytest . fixture def client () : return app . test_client pytest_configure def pytest_configure ( config ) View Source def pytest_configure ( config ): terminal = config . pluginmanager . getplugin ( \"terminal\" ) terminal . TerminalReporter . showfspath = False pytest_runtest_setup def pytest_runtest_setup ( item ) View Source def pytest_runtest_setup ( item ): for marker in item . iter_markers ( name = \"slow\" ): if \"SKIP_SLOW\" in os . environ : pytest . skip ( \"slow test\" )","title":"Conftest"},{"location":"reference/app/tests/conftest/#module-apptestsconftest","text":"View Source import os import pytest from app.views import app def pytest_configure ( config ): terminal = config . pluginmanager . getplugin ( \"terminal\" ) terminal . TerminalReporter . showfspath = False def pytest_runtest_setup ( item ): for marker in item . iter_markers ( name = \"slow\" ): if \"SKIP_SLOW\" in os . environ : pytest . skip ( \"slow test\" ) @pytest.fixture def client (): return app . test_client","title":"Module app.tests.conftest"},{"location":"reference/app/tests/conftest/#functions","text":"","title":"Functions"},{"location":"reference/app/tests/conftest/#client","text":"def client ( ) View Source @pytest . fixture def client () : return app . test_client","title":"client"},{"location":"reference/app/tests/conftest/#pytest_configure","text":"def pytest_configure ( config ) View Source def pytest_configure ( config ): terminal = config . pluginmanager . getplugin ( \"terminal\" ) terminal . TerminalReporter . showfspath = False","title":"pytest_configure"},{"location":"reference/app/tests/conftest/#pytest_runtest_setup","text":"def pytest_runtest_setup ( item ) View Source def pytest_runtest_setup ( item ): for marker in item . iter_markers ( name = \"slow\" ): if \"SKIP_SLOW\" in os . environ : pytest . skip ( \"slow test\" )","title":"pytest_runtest_setup"},{"location":"reference/app/tests/test_apis/","text":"Module app.tests.test_apis View Source import json import pytest def describe_template_list (): def describe_GET (): @pytest.mark.slow def it_returns_all_templates ( expect , client ): request , response = client . get ( \"/templates\" ) expect ( response . status ) == 200 def describe_template_detail (): def describe_GET (): def it_returns_sample_images ( expect , client ): request , response = client . get ( \"/templates/iw\" ) expect ( response . status ) == 200 expect ( response . json ) == { \"name\" : \"Insanity Wolf\" , \"key\" : \"iw\" , \"styles\" : [], \"blank\" : \"http://localhost:5000/images/iw.png\" , \"sample\" : \"http://localhost:5000/images/iw/DOES_TESTING/IN_PRODUCTION.png\" , \"source\" : \"http://knowyourmeme.com/memes/insanity-wolf\" , \"_self\" : \"http://localhost:5000/templates/iw\" , } def it_returns_404_when_missing ( expect , client ): request , response = client . get ( \"/templates/foobar\" ) expect ( response . status ) == 404 def describe_POST (): def it_returns_an_image_url ( expect , client ): data = { \"text_lines\" : [ \"foo\" , \"bar\" ], \"extension\" : \"jpg\" } request , response = client . post ( \"/templates/iw\" , data = json . dumps ( data )) expect ( response . status ) == 201 expect ( response . json ) == { \"url\" : \"http://localhost:5000/images/iw/foo/bar.jpg\" } def it_supports_custom_backgrounds ( expect , client ): data = { \"image_url\" : \"https://www.gstatic.com/webp/gallery/3.png\" , \"text_lines\" : [ \"foo\" , \"bar\" ], \"extension\" : \"jpg\" , } request , response = client . post ( \"/templates/custom\" , data = json . dumps ( data )) expect ( response . status ) == 201 expect ( response . json ) == { \"url\" : \"http://localhost:5000/images/custom/foo/bar.jpg\" \"?background=https://www.gstatic.com/webp/gallery/3.png\" } @pytest.mark.parametrize ( \"key\" , [ \"fry\" , \"custom\" ]) def it_redirects_if_requested ( expect , client , key ): data = { \"text_lines\" : [ \"abc\" ], \"redirect\" : True } request , response = client . post ( f \"/templates/{key}\" , data = json . dumps ( data ), allow_redirects = False ) expect ( response . status ) == 302 def describe_image_list (): def describe_GET (): @pytest.mark.slow def it_returns_sample_image_urls ( expect , client ): request , response = client . get ( \"/images\" ) expect ( response . status ) == 200 expect ( response . json ) . contains ( { \"url\" : \"http://localhost:5000/images/iw/DOES_TESTING/IN_PRODUCTION.png\" , \"template\" : \"http://localhost:5000/templates/iw\" , } ) def describe_POST (): def it_returns_an_image_url ( expect , client ): data = { \"template_key\" : \"iw\" , \"text_lines\" : [ \"foo\" , \"bar\" ]} request , response = client . post ( \"/images\" , data = json . dumps ( data )) expect ( response . status ) == 201 expect ( response . json ) == { \"url\" : \"http://localhost:5000/images/iw/foo/bar.png\" } def it_accepts_form_data ( expect , client ): data = { \"template_key\" : \"iw\" , \"text_lines[]\" : [ \"foo\" , \"bar\" ]} request , response = client . post ( \"/images\" , data = data ) print ( response . json ) print ( response . text ) expect ( response . status ) == 201 expect ( response . json ) == { \"url\" : \"http://localhost:5000/images/iw/foo/bar.png\" } def it_requires_template_key ( expect , client ): data = { \"text_lines\" : [ \"foo\" , \"bar\" ]} request , response = client . post ( \"/images\" , data = json . dumps ( data )) expect ( response . status ) == 400 expect ( response . json ) == { \"error\" : '\"template_key\" is required' } def it_handles_missing_text_lines ( expect , client ): data = { \"template_key\" : \"iw\" } request , response = client . post ( \"/images\" , data = json . dumps ( data )) expect ( response . status ) == 201 expect ( response . json ) == { \"url\" : \"http://localhost:5000/images/iw/_.png\" } def it_redirects_if_requested ( expect , client ): data = { \"template_key\" : \"iw\" , \"text_lines\" : [ \"abc\" ], \"redirect\" : True } request , response = client . post ( \"/images\" , data = json . dumps ( data ), allow_redirects = False ) expect ( response . status ) == 302 def describe_preview (): def it_returns_an_image ( expect , client ): path = \"/images/preview.jpg\" request , response = client . get ( path ) expect ( response . status ) == 200 expect ( response . headers [ \"content-type\" ]) == \"image/jpeg\" def describe_image_detail (): @pytest.mark.parametrize ( ( \"path\" , \"content_type\" ), [ ( \"/images/fry/test.png\" , \"image/png\" ), ( \"/images/fry/test.jpg\" , \"image/jpeg\" ), ], ) def it_returns_an_image ( expect , client , path , content_type ): request , response = client . get ( path ) expect ( response . status ) == 200 expect ( response . headers [ \"content-type\" ]) == content_type @pytest.mark.parametrize ( ( \"path\" , \"content_type\" ), [ ( \"/images/fry.png\" , \"image/png\" ), ( \"/images/fry.jpg\" , \"image/jpeg\" ), ], ) def it_returns_blank_templates_when_no_slug ( expect , client , path , content_type ): request , response = client . get ( path ) expect ( response . status ) == 200 expect ( response . headers [ \"content-type\" ]) == content_type def it_handles_unknown_templates ( expect , client ): request , response = client . get ( \"/images/unknown/test.png\" ) expect ( response . status ) == 404 expect ( response . headers [ \"content-type\" ]) == \"image/png\" def it_rejects_extremely_long_urls ( expect , client ): text = \"test-\" * 50 request , response = client . get ( f \"/images/fry/{text}.jpg\" ) expect ( response . status ) == 414 expect ( response . headers [ \"content-type\" ]) == \"image/jpeg\" def describe_styles (): def it_supports_alternate_styles ( expect , client ): request , response = client . get ( \"/images/ds/one/two.png?style=maga\" ) expect ( response . status ) == 200 expect ( response . headers [ \"content-type\" ]) == \"image/png\" def it_rejects_invalid_styles ( expect , client ): request , response = client . get ( \"/images/ds/one/two.png?style=foobar\" ) expect ( response . status ) == 422 expect ( response . headers [ \"content-type\" ]) == \"image/png\" def describe_custom (): @pytest.mark.slow def it_supports_custom_templates ( expect , client ): request , response = client . get ( \"/images/custom/test.png\" \"?background=https://www.gstatic.com/webp/gallery/3.jpg\" ) expect ( response . status ) == 200 expect ( response . headers [ \"content-type\" ]) == \"image/png\" def it_requires_an_image_with_custom_templates ( expect , client ): request , response = client . get ( \"/images/custom/test.png\" ) expect ( response . status ) == 422 expect ( response . headers [ \"content-type\" ]) == \"image/png\" def it_handles_invalid_urls ( expect , client ): request , response = client . get ( \"/images/custom/test.png\" \"?background=foobar\" ) expect ( response . status ) == 415 expect ( response . headers [ \"content-type\" ]) == \"image/png\" def it_handles_missing_urls ( expect , client ): request , response = client . get ( \"/images/custom/test.png\" \"?background=http://example.com/does_not_exist.png\" ) expect ( response . status ) == 415 expect ( response . headers [ \"content-type\" ]) == \"image/png\" def describe_redirects (): @pytest.mark.parametrize ( \"ext\" , [ \"png\" , \"jpg\" ]) def it_redirects_to_normalized_slug ( expect , client , ext ): request , response = client . get ( f \"/images/fry/One Two.{ext}\" , allow_redirects = False ) expect ( response . status ) == 301 expect ( response . headers [ \"Location\" ]) == f \"/images/fry/One_Two.{ext}\" @pytest.mark.parametrize ( \"ext\" , [ \"png\" , \"jpg\" ]) def it_preserves_query_params_when_redirecting ( expect , client , ext ): request , response = client . get ( f \"/images/custom/One Two.{ext}?alt=http://example.com\" , allow_redirects = False , ) redirect = f \"/images/custom/One_Two.{ext}?alt=http://example.com\" expect ( response . status ) == 301 expect ( response . headers [ \"Location\" ]) == redirect def it_handles_encoded_newlines ( expect , client ): request , response = client . get ( \"/images/fry/1 2%0A3.jpg\" , allow_redirects = False ) redirect = \"/images/fry/1_2~n3.jpg\" expect ( response . status ) == 301 expect ( response . headers [ \"Location\" ]) == redirect def describe_shortcuts (): def it_redirects_to_sample_image_when_no_extension ( expect , client ): request , response = client . get ( \"/images/fry\" , allow_redirects = False ) redirect = \"/images/fry/NOT_SURE_IF_TROLLING/OR_JUST_STUPID\" expect ( response . status ) == 302 expect ( response . headers [ \"Location\" ]) == redirect def it_redirects_to_custom_image_when_no_extension ( expect , client ): request , response = client . get ( \"/images/fry/test\" , allow_redirects = False ) expect ( response . status ) == 302 expect ( response . headers [ \"Location\" ]) == \"/images/fry/test.png\" def describe_legacy (): @pytest.mark.slow def it_accepts_alt_for_template ( expect , client ): request , response = client . get ( \"/images/custom/test.png\" \"?alt=https://www.gstatic.com/webp/gallery/3.jpg\" ) expect ( response . status ) == 200 expect ( response . headers [ \"content-type\" ]) == \"image/png\" @pytest.mark.slow def it_accepts_alt_for_style ( expect , client ): request , response = client . get ( \"/images/sad-biden/test.png?style=scowl\" ) expect ( response . status ) == 200 request , response2 = client . get ( \"/images/sad-biden/test.png?alt=scowl\" ) expect ( response . status ) == 200 expect ( len ( response . content )) == len ( response2 . content ) @pytest.mark.parametrize ( \"ext\" , [ \"png\" , \"jpg\" ]) def it_redirects_to_sample_image ( expect , client , ext ): request , response = client . get ( f \"/fry.{ext}\" , allow_redirects = False ) redirect = f \"/images/fry/NOT_SURE_IF_TROLLING/OR_JUST_STUPID.{ext}\" expect ( response . status ) == 302 expect ( response . headers [ \"Location\" ]) == redirect @pytest.mark.parametrize ( \"ext\" , [ \"png\" , \"jpg\" ]) def it_redirects_to_custom_image ( expect , client , ext ): request , response = client . get ( f \"/fry/test.{ext}\" , allow_redirects = False ) expect ( response . status ) == 302 expect ( response . headers [ \"Location\" ]) == f \"/images/fry/test.{ext}\" Functions describe_image_detail def describe_image_detail ( ) View Source def describe_image_detail () : @pytest . mark . parametrize ( ( \"path\" , \"content_type\" ), [ (\"/images/fry/test.png\", \"image/png\"), (\"/images/fry/test.jpg\", \"image/jpeg\"), ] , ) def it_returns_an_image ( expect , client , path , content_type ) : request , response = client . get ( path ) expect ( response . status ) == 200 expect ( response . headers [ \"content-type\" ] ) == content_type @pytest . mark . parametrize ( ( \"path\" , \"content_type\" ), [ (\"/images/fry.png\", \"image/png\"), (\"/images/fry.jpg\", \"image/jpeg\"), ] , ) def it_returns_blank_templates_when_no_slug ( expect , client , path , content_type ) : request , response = client . get ( path ) expect ( response . status ) == 200 expect ( response . headers [ \"content-type\" ] ) == content_type def it_handles_unknown_templates ( expect , client ) : request , response = client . get ( \"/images/unknown/test.png\" ) expect ( response . status ) == 404 expect ( response . headers [ \"content-type\" ] ) == \"image/png\" def it_rejects_extremely_long_urls ( expect , client ) : text = \"test-\" * 50 request , response = client . get ( f \"/images/fry/{text}.jpg\" ) expect ( response . status ) == 414 expect ( response . headers [ \"content-type\" ] ) == \"image/jpeg\" def describe_styles () : def it_supports_alternate_styles ( expect , client ) : request , response = client . get ( \"/images/ds/one/two.png?style=maga\" ) expect ( response . status ) == 200 expect ( response . headers [ \"content-type\" ] ) == \"image/png\" def it_rejects_invalid_styles ( expect , client ) : request , response = client . get ( \"/images/ds/one/two.png?style=foobar\" ) expect ( response . status ) == 422 expect ( response . headers [ \"content-type\" ] ) == \"image/png\" def describe_custom () : @pytest . mark . slow def it_supports_custom_templates ( expect , client ) : request , response = client . get ( \"/images/custom/test.png\" \"?background=https://www.gstatic.com/webp/gallery/3.jpg\" ) expect ( response . status ) == 200 expect ( response . headers [ \"content-type\" ] ) == \"image/png\" def it_requires_an_image_with_custom_templates ( expect , client ) : request , response = client . get ( \"/images/custom/test.png\" ) expect ( response . status ) == 422 expect ( response . headers [ \"content-type\" ] ) == \"image/png\" def it_handles_invalid_urls ( expect , client ) : request , response = client . get ( \"/images/custom/test.png\" \"?background=foobar\" ) expect ( response . status ) == 415 expect ( response . headers [ \"content-type\" ] ) == \"image/png\" def it_handles_missing_urls ( expect , client ) : request , response = client . get ( \"/images/custom/test.png\" \"?background=http://example.com/does_not_exist.png\" ) expect ( response . status ) == 415 expect ( response . headers [ \"content-type\" ] ) == \"image/png\" def describe_redirects () : @pytest . mark . parametrize ( \"ext\" , [ \"png\", \"jpg\" ] ) def it_redirects_to_normalized_slug ( expect , client , ext ) : request , response = client . get ( f \"/images/fry/One Two.{ext}\" , allow_redirects = False ) expect ( response . status ) == 301 expect ( response . headers [ \"Location\" ] ) == f \"/images/fry/One_Two.{ext}\" @pytest . mark . parametrize ( \"ext\" , [ \"png\", \"jpg\" ] ) def it_preserves_query_params_when_redirecting ( expect , client , ext ) : request , response = client . get ( f \"/images/custom/One Two.{ext}?alt=http://example.com\" , allow_redirects = False , ) redirect = f \"/images/custom/One_Two.{ext}?alt=http://example.com\" expect ( response . status ) == 301 expect ( response . headers [ \"Location\" ] ) == redirect def it_handles_encoded_newlines ( expect , client ) : request , response = client . get ( \"/images/fry/1 2%0A3.jpg\" , allow_redirects = False ) redirect = \"/images/fry/1_2~n3.jpg\" expect ( response . status ) == 301 expect ( response . headers [ \"Location\" ] ) == redirect def describe_shortcuts () : def it_redirects_to_sample_image_when_no_extension ( expect , client ) : request , response = client . get ( \"/images/fry\" , allow_redirects = False ) redirect = \"/images/fry/NOT_SURE_IF_TROLLING/OR_JUST_STUPID\" expect ( response . status ) == 302 expect ( response . headers [ \"Location\" ] ) == redirect def it_redirects_to_custom_image_when_no_extension ( expect , client ) : request , response = client . get ( \"/images/fry/test\" , allow_redirects = False ) expect ( response . status ) == 302 expect ( response . headers [ \"Location\" ] ) == \"/images/fry/test.png\" def describe_legacy () : @pytest . mark . slow def it_accepts_alt_for_template ( expect , client ) : request , response = client . get ( \"/images/custom/test.png\" \"?alt=https://www.gstatic.com/webp/gallery/3.jpg\" ) expect ( response . status ) == 200 expect ( response . headers [ \"content-type\" ] ) == \"image/png\" @pytest . mark . slow def it_accepts_alt_for_style ( expect , client ) : request , response = client . get ( \"/images/sad-biden/test.png?style=scowl\" ) expect ( response . status ) == 200 request , response2 = client . get ( \"/images/sad-biden/test.png?alt=scowl\" ) expect ( response . status ) == 200 expect ( len ( response . content )) == len ( response2 . content ) @pytest . mark . parametrize ( \"ext\" , [ \"png\", \"jpg\" ] ) def it_redirects_to_sample_image ( expect , client , ext ) : request , response = client . get ( f \"/fry.{ext}\" , allow_redirects = False ) redirect = f \"/images/fry/NOT_SURE_IF_TROLLING/OR_JUST_STUPID.{ext}\" expect ( response . status ) == 302 expect ( response . headers [ \"Location\" ] ) == redirect @pytest . mark . parametrize ( \"ext\" , [ \"png\", \"jpg\" ] ) def it_redirects_to_custom_image ( expect , client , ext ) : request , response = client . get ( f \"/fry/test.{ext}\" , allow_redirects = False ) expect ( response . status ) == 302 expect ( response . headers [ \"Location\" ] ) == f \"/images/fry/test.{ext}\" describe_image_list def describe_image_list ( ) View Source def describe_image_list () : def describe_GET () : @pytest . mark . slow def it_returns_sample_image_urls ( expect , client ) : request , response = client . get ( \"/images\" ) expect ( response . status ) == 200 expect ( response . json ). contains ( { \"url\" : \"http://localhost:5000/images/iw/DOES_TESTING/IN_PRODUCTION.png\" , \"template\" : \"http://localhost:5000/templates/iw\" , } ) def describe_POST () : def it_returns_an_image_url ( expect , client ) : data = { \"template_key\" : \"iw\" , \"text_lines\" : [ \"foo\", \"bar\" ] } request , response = client . post ( \"/images\" , data = json . dumps ( data )) expect ( response . status ) == 201 expect ( response . json ) == { \"url\" : \"http://localhost:5000/images/iw/foo/bar.png\" } def it_accepts_form_data ( expect , client ) : data = { \"template_key\" : \"iw\" , \"text_lines[]\" : [ \"foo\", \"bar\" ] } request , response = client . post ( \"/images\" , data = data ) print ( response . json ) print ( response . text ) expect ( response . status ) == 201 expect ( response . json ) == { \"url\" : \"http://localhost:5000/images/iw/foo/bar.png\" } def it_requires_template_key ( expect , client ) : data = { \"text_lines\" : [ \"foo\", \"bar\" ] } request , response = client . post ( \"/images\" , data = json . dumps ( data )) expect ( response . status ) == 400 expect ( response . json ) == { \"error\" : '\"template_key\" is required' } def it_handles_missing_text_lines ( expect , client ) : data = { \"template_key\" : \"iw\" } request , response = client . post ( \"/images\" , data = json . dumps ( data )) expect ( response . status ) == 201 expect ( response . json ) == { \"url\" : \"http://localhost:5000/images/iw/_.png\" } def it_redirects_if_requested ( expect , client ) : data = { \"template_key\" : \"iw\" , \"text_lines\" : [ \"abc\" ] , \"redirect\" : True } request , response = client . post ( \"/images\" , data = json . dumps ( data ), allow_redirects = False ) expect ( response . status ) == 302 describe_preview def describe_preview ( ) View Source def describe_preview (): def it_returns_an_image ( expect , client ): path = \"/images/preview.jpg\" request , response = client . get ( path ) expect ( response . status ) == 200 expect ( response . headers [ \"content-type\" ]) == \"image/jpeg\" describe_template_detail def describe_template_detail ( ) View Source def describe_template_detail () : def describe_GET () : def it_returns_sample_images ( expect , client ) : request , response = client . get ( \"/templates/iw\" ) expect ( response . status ) == 200 expect ( response . json ) == { \"name\" : \"Insanity Wolf\" , \"key\" : \"iw\" , \"styles\" : [] , \"blank\" : \"http://localhost:5000/images/iw.png\" , \"sample\" : \"http://localhost:5000/images/iw/DOES_TESTING/IN_PRODUCTION.png\" , \"source\" : \"http://knowyourmeme.com/memes/insanity-wolf\" , \"_self\" : \"http://localhost:5000/templates/iw\" , } def it_returns_404_when_missing ( expect , client ) : request , response = client . get ( \"/templates/foobar\" ) expect ( response . status ) == 404 def describe_POST () : def it_returns_an_image_url ( expect , client ) : data = { \"text_lines\" : [ \"foo\", \"bar\" ] , \"extension\" : \"jpg\" } request , response = client . post ( \"/templates/iw\" , data = json . dumps ( data )) expect ( response . status ) == 201 expect ( response . json ) == { \"url\" : \"http://localhost:5000/images/iw/foo/bar.jpg\" } def it_supports_custom_backgrounds ( expect , client ) : data = { \"image_url\" : \"https://www.gstatic.com/webp/gallery/3.png\" , \"text_lines\" : [ \"foo\", \"bar\" ] , \"extension\" : \"jpg\" , } request , response = client . post ( \"/templates/custom\" , data = json . dumps ( data )) expect ( response . status ) == 201 expect ( response . json ) == { \"url\" : \"http://localhost:5000/images/custom/foo/bar.jpg\" \"?background=https://www.gstatic.com/webp/gallery/3.png\" } @pytest . mark . parametrize ( \"key\" , [ \"fry\", \"custom\" ] ) def it_redirects_if_requested ( expect , client , key ) : data = { \"text_lines\" : [ \"abc\" ] , \"redirect\" : True } request , response = client . post ( f \"/templates/{key}\" , data = json . dumps ( data ), allow_redirects = False ) expect ( response . status ) == 302 describe_template_list def describe_template_list ( ) View Source def describe_template_list () : def describe_GET () : @pytest . mark . slow def it_returns_all_templates ( expect , client ) : request , response = client . get ( \"/templates\" ) expect ( response . status ) == 200","title":"Test Apis"},{"location":"reference/app/tests/test_apis/#module-appteststest_apis","text":"View Source import json import pytest def describe_template_list (): def describe_GET (): @pytest.mark.slow def it_returns_all_templates ( expect , client ): request , response = client . get ( \"/templates\" ) expect ( response . status ) == 200 def describe_template_detail (): def describe_GET (): def it_returns_sample_images ( expect , client ): request , response = client . get ( \"/templates/iw\" ) expect ( response . status ) == 200 expect ( response . json ) == { \"name\" : \"Insanity Wolf\" , \"key\" : \"iw\" , \"styles\" : [], \"blank\" : \"http://localhost:5000/images/iw.png\" , \"sample\" : \"http://localhost:5000/images/iw/DOES_TESTING/IN_PRODUCTION.png\" , \"source\" : \"http://knowyourmeme.com/memes/insanity-wolf\" , \"_self\" : \"http://localhost:5000/templates/iw\" , } def it_returns_404_when_missing ( expect , client ): request , response = client . get ( \"/templates/foobar\" ) expect ( response . status ) == 404 def describe_POST (): def it_returns_an_image_url ( expect , client ): data = { \"text_lines\" : [ \"foo\" , \"bar\" ], \"extension\" : \"jpg\" } request , response = client . post ( \"/templates/iw\" , data = json . dumps ( data )) expect ( response . status ) == 201 expect ( response . json ) == { \"url\" : \"http://localhost:5000/images/iw/foo/bar.jpg\" } def it_supports_custom_backgrounds ( expect , client ): data = { \"image_url\" : \"https://www.gstatic.com/webp/gallery/3.png\" , \"text_lines\" : [ \"foo\" , \"bar\" ], \"extension\" : \"jpg\" , } request , response = client . post ( \"/templates/custom\" , data = json . dumps ( data )) expect ( response . status ) == 201 expect ( response . json ) == { \"url\" : \"http://localhost:5000/images/custom/foo/bar.jpg\" \"?background=https://www.gstatic.com/webp/gallery/3.png\" } @pytest.mark.parametrize ( \"key\" , [ \"fry\" , \"custom\" ]) def it_redirects_if_requested ( expect , client , key ): data = { \"text_lines\" : [ \"abc\" ], \"redirect\" : True } request , response = client . post ( f \"/templates/{key}\" , data = json . dumps ( data ), allow_redirects = False ) expect ( response . status ) == 302 def describe_image_list (): def describe_GET (): @pytest.mark.slow def it_returns_sample_image_urls ( expect , client ): request , response = client . get ( \"/images\" ) expect ( response . status ) == 200 expect ( response . json ) . contains ( { \"url\" : \"http://localhost:5000/images/iw/DOES_TESTING/IN_PRODUCTION.png\" , \"template\" : \"http://localhost:5000/templates/iw\" , } ) def describe_POST (): def it_returns_an_image_url ( expect , client ): data = { \"template_key\" : \"iw\" , \"text_lines\" : [ \"foo\" , \"bar\" ]} request , response = client . post ( \"/images\" , data = json . dumps ( data )) expect ( response . status ) == 201 expect ( response . json ) == { \"url\" : \"http://localhost:5000/images/iw/foo/bar.png\" } def it_accepts_form_data ( expect , client ): data = { \"template_key\" : \"iw\" , \"text_lines[]\" : [ \"foo\" , \"bar\" ]} request , response = client . post ( \"/images\" , data = data ) print ( response . json ) print ( response . text ) expect ( response . status ) == 201 expect ( response . json ) == { \"url\" : \"http://localhost:5000/images/iw/foo/bar.png\" } def it_requires_template_key ( expect , client ): data = { \"text_lines\" : [ \"foo\" , \"bar\" ]} request , response = client . post ( \"/images\" , data = json . dumps ( data )) expect ( response . status ) == 400 expect ( response . json ) == { \"error\" : '\"template_key\" is required' } def it_handles_missing_text_lines ( expect , client ): data = { \"template_key\" : \"iw\" } request , response = client . post ( \"/images\" , data = json . dumps ( data )) expect ( response . status ) == 201 expect ( response . json ) == { \"url\" : \"http://localhost:5000/images/iw/_.png\" } def it_redirects_if_requested ( expect , client ): data = { \"template_key\" : \"iw\" , \"text_lines\" : [ \"abc\" ], \"redirect\" : True } request , response = client . post ( \"/images\" , data = json . dumps ( data ), allow_redirects = False ) expect ( response . status ) == 302 def describe_preview (): def it_returns_an_image ( expect , client ): path = \"/images/preview.jpg\" request , response = client . get ( path ) expect ( response . status ) == 200 expect ( response . headers [ \"content-type\" ]) == \"image/jpeg\" def describe_image_detail (): @pytest.mark.parametrize ( ( \"path\" , \"content_type\" ), [ ( \"/images/fry/test.png\" , \"image/png\" ), ( \"/images/fry/test.jpg\" , \"image/jpeg\" ), ], ) def it_returns_an_image ( expect , client , path , content_type ): request , response = client . get ( path ) expect ( response . status ) == 200 expect ( response . headers [ \"content-type\" ]) == content_type @pytest.mark.parametrize ( ( \"path\" , \"content_type\" ), [ ( \"/images/fry.png\" , \"image/png\" ), ( \"/images/fry.jpg\" , \"image/jpeg\" ), ], ) def it_returns_blank_templates_when_no_slug ( expect , client , path , content_type ): request , response = client . get ( path ) expect ( response . status ) == 200 expect ( response . headers [ \"content-type\" ]) == content_type def it_handles_unknown_templates ( expect , client ): request , response = client . get ( \"/images/unknown/test.png\" ) expect ( response . status ) == 404 expect ( response . headers [ \"content-type\" ]) == \"image/png\" def it_rejects_extremely_long_urls ( expect , client ): text = \"test-\" * 50 request , response = client . get ( f \"/images/fry/{text}.jpg\" ) expect ( response . status ) == 414 expect ( response . headers [ \"content-type\" ]) == \"image/jpeg\" def describe_styles (): def it_supports_alternate_styles ( expect , client ): request , response = client . get ( \"/images/ds/one/two.png?style=maga\" ) expect ( response . status ) == 200 expect ( response . headers [ \"content-type\" ]) == \"image/png\" def it_rejects_invalid_styles ( expect , client ): request , response = client . get ( \"/images/ds/one/two.png?style=foobar\" ) expect ( response . status ) == 422 expect ( response . headers [ \"content-type\" ]) == \"image/png\" def describe_custom (): @pytest.mark.slow def it_supports_custom_templates ( expect , client ): request , response = client . get ( \"/images/custom/test.png\" \"?background=https://www.gstatic.com/webp/gallery/3.jpg\" ) expect ( response . status ) == 200 expect ( response . headers [ \"content-type\" ]) == \"image/png\" def it_requires_an_image_with_custom_templates ( expect , client ): request , response = client . get ( \"/images/custom/test.png\" ) expect ( response . status ) == 422 expect ( response . headers [ \"content-type\" ]) == \"image/png\" def it_handles_invalid_urls ( expect , client ): request , response = client . get ( \"/images/custom/test.png\" \"?background=foobar\" ) expect ( response . status ) == 415 expect ( response . headers [ \"content-type\" ]) == \"image/png\" def it_handles_missing_urls ( expect , client ): request , response = client . get ( \"/images/custom/test.png\" \"?background=http://example.com/does_not_exist.png\" ) expect ( response . status ) == 415 expect ( response . headers [ \"content-type\" ]) == \"image/png\" def describe_redirects (): @pytest.mark.parametrize ( \"ext\" , [ \"png\" , \"jpg\" ]) def it_redirects_to_normalized_slug ( expect , client , ext ): request , response = client . get ( f \"/images/fry/One Two.{ext}\" , allow_redirects = False ) expect ( response . status ) == 301 expect ( response . headers [ \"Location\" ]) == f \"/images/fry/One_Two.{ext}\" @pytest.mark.parametrize ( \"ext\" , [ \"png\" , \"jpg\" ]) def it_preserves_query_params_when_redirecting ( expect , client , ext ): request , response = client . get ( f \"/images/custom/One Two.{ext}?alt=http://example.com\" , allow_redirects = False , ) redirect = f \"/images/custom/One_Two.{ext}?alt=http://example.com\" expect ( response . status ) == 301 expect ( response . headers [ \"Location\" ]) == redirect def it_handles_encoded_newlines ( expect , client ): request , response = client . get ( \"/images/fry/1 2%0A3.jpg\" , allow_redirects = False ) redirect = \"/images/fry/1_2~n3.jpg\" expect ( response . status ) == 301 expect ( response . headers [ \"Location\" ]) == redirect def describe_shortcuts (): def it_redirects_to_sample_image_when_no_extension ( expect , client ): request , response = client . get ( \"/images/fry\" , allow_redirects = False ) redirect = \"/images/fry/NOT_SURE_IF_TROLLING/OR_JUST_STUPID\" expect ( response . status ) == 302 expect ( response . headers [ \"Location\" ]) == redirect def it_redirects_to_custom_image_when_no_extension ( expect , client ): request , response = client . get ( \"/images/fry/test\" , allow_redirects = False ) expect ( response . status ) == 302 expect ( response . headers [ \"Location\" ]) == \"/images/fry/test.png\" def describe_legacy (): @pytest.mark.slow def it_accepts_alt_for_template ( expect , client ): request , response = client . get ( \"/images/custom/test.png\" \"?alt=https://www.gstatic.com/webp/gallery/3.jpg\" ) expect ( response . status ) == 200 expect ( response . headers [ \"content-type\" ]) == \"image/png\" @pytest.mark.slow def it_accepts_alt_for_style ( expect , client ): request , response = client . get ( \"/images/sad-biden/test.png?style=scowl\" ) expect ( response . status ) == 200 request , response2 = client . get ( \"/images/sad-biden/test.png?alt=scowl\" ) expect ( response . status ) == 200 expect ( len ( response . content )) == len ( response2 . content ) @pytest.mark.parametrize ( \"ext\" , [ \"png\" , \"jpg\" ]) def it_redirects_to_sample_image ( expect , client , ext ): request , response = client . get ( f \"/fry.{ext}\" , allow_redirects = False ) redirect = f \"/images/fry/NOT_SURE_IF_TROLLING/OR_JUST_STUPID.{ext}\" expect ( response . status ) == 302 expect ( response . headers [ \"Location\" ]) == redirect @pytest.mark.parametrize ( \"ext\" , [ \"png\" , \"jpg\" ]) def it_redirects_to_custom_image ( expect , client , ext ): request , response = client . get ( f \"/fry/test.{ext}\" , allow_redirects = False ) expect ( response . status ) == 302 expect ( response . headers [ \"Location\" ]) == f \"/images/fry/test.{ext}\"","title":"Module app.tests.test_apis"},{"location":"reference/app/tests/test_apis/#functions","text":"","title":"Functions"},{"location":"reference/app/tests/test_apis/#describe_image_detail","text":"def describe_image_detail ( ) View Source def describe_image_detail () : @pytest . mark . parametrize ( ( \"path\" , \"content_type\" ), [ (\"/images/fry/test.png\", \"image/png\"), (\"/images/fry/test.jpg\", \"image/jpeg\"), ] , ) def it_returns_an_image ( expect , client , path , content_type ) : request , response = client . get ( path ) expect ( response . status ) == 200 expect ( response . headers [ \"content-type\" ] ) == content_type @pytest . mark . parametrize ( ( \"path\" , \"content_type\" ), [ (\"/images/fry.png\", \"image/png\"), (\"/images/fry.jpg\", \"image/jpeg\"), ] , ) def it_returns_blank_templates_when_no_slug ( expect , client , path , content_type ) : request , response = client . get ( path ) expect ( response . status ) == 200 expect ( response . headers [ \"content-type\" ] ) == content_type def it_handles_unknown_templates ( expect , client ) : request , response = client . get ( \"/images/unknown/test.png\" ) expect ( response . status ) == 404 expect ( response . headers [ \"content-type\" ] ) == \"image/png\" def it_rejects_extremely_long_urls ( expect , client ) : text = \"test-\" * 50 request , response = client . get ( f \"/images/fry/{text}.jpg\" ) expect ( response . status ) == 414 expect ( response . headers [ \"content-type\" ] ) == \"image/jpeg\" def describe_styles () : def it_supports_alternate_styles ( expect , client ) : request , response = client . get ( \"/images/ds/one/two.png?style=maga\" ) expect ( response . status ) == 200 expect ( response . headers [ \"content-type\" ] ) == \"image/png\" def it_rejects_invalid_styles ( expect , client ) : request , response = client . get ( \"/images/ds/one/two.png?style=foobar\" ) expect ( response . status ) == 422 expect ( response . headers [ \"content-type\" ] ) == \"image/png\" def describe_custom () : @pytest . mark . slow def it_supports_custom_templates ( expect , client ) : request , response = client . get ( \"/images/custom/test.png\" \"?background=https://www.gstatic.com/webp/gallery/3.jpg\" ) expect ( response . status ) == 200 expect ( response . headers [ \"content-type\" ] ) == \"image/png\" def it_requires_an_image_with_custom_templates ( expect , client ) : request , response = client . get ( \"/images/custom/test.png\" ) expect ( response . status ) == 422 expect ( response . headers [ \"content-type\" ] ) == \"image/png\" def it_handles_invalid_urls ( expect , client ) : request , response = client . get ( \"/images/custom/test.png\" \"?background=foobar\" ) expect ( response . status ) == 415 expect ( response . headers [ \"content-type\" ] ) == \"image/png\" def it_handles_missing_urls ( expect , client ) : request , response = client . get ( \"/images/custom/test.png\" \"?background=http://example.com/does_not_exist.png\" ) expect ( response . status ) == 415 expect ( response . headers [ \"content-type\" ] ) == \"image/png\" def describe_redirects () : @pytest . mark . parametrize ( \"ext\" , [ \"png\", \"jpg\" ] ) def it_redirects_to_normalized_slug ( expect , client , ext ) : request , response = client . get ( f \"/images/fry/One Two.{ext}\" , allow_redirects = False ) expect ( response . status ) == 301 expect ( response . headers [ \"Location\" ] ) == f \"/images/fry/One_Two.{ext}\" @pytest . mark . parametrize ( \"ext\" , [ \"png\", \"jpg\" ] ) def it_preserves_query_params_when_redirecting ( expect , client , ext ) : request , response = client . get ( f \"/images/custom/One Two.{ext}?alt=http://example.com\" , allow_redirects = False , ) redirect = f \"/images/custom/One_Two.{ext}?alt=http://example.com\" expect ( response . status ) == 301 expect ( response . headers [ \"Location\" ] ) == redirect def it_handles_encoded_newlines ( expect , client ) : request , response = client . get ( \"/images/fry/1 2%0A3.jpg\" , allow_redirects = False ) redirect = \"/images/fry/1_2~n3.jpg\" expect ( response . status ) == 301 expect ( response . headers [ \"Location\" ] ) == redirect def describe_shortcuts () : def it_redirects_to_sample_image_when_no_extension ( expect , client ) : request , response = client . get ( \"/images/fry\" , allow_redirects = False ) redirect = \"/images/fry/NOT_SURE_IF_TROLLING/OR_JUST_STUPID\" expect ( response . status ) == 302 expect ( response . headers [ \"Location\" ] ) == redirect def it_redirects_to_custom_image_when_no_extension ( expect , client ) : request , response = client . get ( \"/images/fry/test\" , allow_redirects = False ) expect ( response . status ) == 302 expect ( response . headers [ \"Location\" ] ) == \"/images/fry/test.png\" def describe_legacy () : @pytest . mark . slow def it_accepts_alt_for_template ( expect , client ) : request , response = client . get ( \"/images/custom/test.png\" \"?alt=https://www.gstatic.com/webp/gallery/3.jpg\" ) expect ( response . status ) == 200 expect ( response . headers [ \"content-type\" ] ) == \"image/png\" @pytest . mark . slow def it_accepts_alt_for_style ( expect , client ) : request , response = client . get ( \"/images/sad-biden/test.png?style=scowl\" ) expect ( response . status ) == 200 request , response2 = client . get ( \"/images/sad-biden/test.png?alt=scowl\" ) expect ( response . status ) == 200 expect ( len ( response . content )) == len ( response2 . content ) @pytest . mark . parametrize ( \"ext\" , [ \"png\", \"jpg\" ] ) def it_redirects_to_sample_image ( expect , client , ext ) : request , response = client . get ( f \"/fry.{ext}\" , allow_redirects = False ) redirect = f \"/images/fry/NOT_SURE_IF_TROLLING/OR_JUST_STUPID.{ext}\" expect ( response . status ) == 302 expect ( response . headers [ \"Location\" ] ) == redirect @pytest . mark . parametrize ( \"ext\" , [ \"png\", \"jpg\" ] ) def it_redirects_to_custom_image ( expect , client , ext ) : request , response = client . get ( f \"/fry/test.{ext}\" , allow_redirects = False ) expect ( response . status ) == 302 expect ( response . headers [ \"Location\" ] ) == f \"/images/fry/test.{ext}\"","title":"describe_image_detail"},{"location":"reference/app/tests/test_apis/#describe_image_list","text":"def describe_image_list ( ) View Source def describe_image_list () : def describe_GET () : @pytest . mark . slow def it_returns_sample_image_urls ( expect , client ) : request , response = client . get ( \"/images\" ) expect ( response . status ) == 200 expect ( response . json ). contains ( { \"url\" : \"http://localhost:5000/images/iw/DOES_TESTING/IN_PRODUCTION.png\" , \"template\" : \"http://localhost:5000/templates/iw\" , } ) def describe_POST () : def it_returns_an_image_url ( expect , client ) : data = { \"template_key\" : \"iw\" , \"text_lines\" : [ \"foo\", \"bar\" ] } request , response = client . post ( \"/images\" , data = json . dumps ( data )) expect ( response . status ) == 201 expect ( response . json ) == { \"url\" : \"http://localhost:5000/images/iw/foo/bar.png\" } def it_accepts_form_data ( expect , client ) : data = { \"template_key\" : \"iw\" , \"text_lines[]\" : [ \"foo\", \"bar\" ] } request , response = client . post ( \"/images\" , data = data ) print ( response . json ) print ( response . text ) expect ( response . status ) == 201 expect ( response . json ) == { \"url\" : \"http://localhost:5000/images/iw/foo/bar.png\" } def it_requires_template_key ( expect , client ) : data = { \"text_lines\" : [ \"foo\", \"bar\" ] } request , response = client . post ( \"/images\" , data = json . dumps ( data )) expect ( response . status ) == 400 expect ( response . json ) == { \"error\" : '\"template_key\" is required' } def it_handles_missing_text_lines ( expect , client ) : data = { \"template_key\" : \"iw\" } request , response = client . post ( \"/images\" , data = json . dumps ( data )) expect ( response . status ) == 201 expect ( response . json ) == { \"url\" : \"http://localhost:5000/images/iw/_.png\" } def it_redirects_if_requested ( expect , client ) : data = { \"template_key\" : \"iw\" , \"text_lines\" : [ \"abc\" ] , \"redirect\" : True } request , response = client . post ( \"/images\" , data = json . dumps ( data ), allow_redirects = False ) expect ( response . status ) == 302","title":"describe_image_list"},{"location":"reference/app/tests/test_apis/#describe_preview","text":"def describe_preview ( ) View Source def describe_preview (): def it_returns_an_image ( expect , client ): path = \"/images/preview.jpg\" request , response = client . get ( path ) expect ( response . status ) == 200 expect ( response . headers [ \"content-type\" ]) == \"image/jpeg\"","title":"describe_preview"},{"location":"reference/app/tests/test_apis/#describe_template_detail","text":"def describe_template_detail ( ) View Source def describe_template_detail () : def describe_GET () : def it_returns_sample_images ( expect , client ) : request , response = client . get ( \"/templates/iw\" ) expect ( response . status ) == 200 expect ( response . json ) == { \"name\" : \"Insanity Wolf\" , \"key\" : \"iw\" , \"styles\" : [] , \"blank\" : \"http://localhost:5000/images/iw.png\" , \"sample\" : \"http://localhost:5000/images/iw/DOES_TESTING/IN_PRODUCTION.png\" , \"source\" : \"http://knowyourmeme.com/memes/insanity-wolf\" , \"_self\" : \"http://localhost:5000/templates/iw\" , } def it_returns_404_when_missing ( expect , client ) : request , response = client . get ( \"/templates/foobar\" ) expect ( response . status ) == 404 def describe_POST () : def it_returns_an_image_url ( expect , client ) : data = { \"text_lines\" : [ \"foo\", \"bar\" ] , \"extension\" : \"jpg\" } request , response = client . post ( \"/templates/iw\" , data = json . dumps ( data )) expect ( response . status ) == 201 expect ( response . json ) == { \"url\" : \"http://localhost:5000/images/iw/foo/bar.jpg\" } def it_supports_custom_backgrounds ( expect , client ) : data = { \"image_url\" : \"https://www.gstatic.com/webp/gallery/3.png\" , \"text_lines\" : [ \"foo\", \"bar\" ] , \"extension\" : \"jpg\" , } request , response = client . post ( \"/templates/custom\" , data = json . dumps ( data )) expect ( response . status ) == 201 expect ( response . json ) == { \"url\" : \"http://localhost:5000/images/custom/foo/bar.jpg\" \"?background=https://www.gstatic.com/webp/gallery/3.png\" } @pytest . mark . parametrize ( \"key\" , [ \"fry\", \"custom\" ] ) def it_redirects_if_requested ( expect , client , key ) : data = { \"text_lines\" : [ \"abc\" ] , \"redirect\" : True } request , response = client . post ( f \"/templates/{key}\" , data = json . dumps ( data ), allow_redirects = False ) expect ( response . status ) == 302","title":"describe_template_detail"},{"location":"reference/app/tests/test_apis/#describe_template_list","text":"def describe_template_list ( ) View Source def describe_template_list () : def describe_GET () : @pytest . mark . slow def it_returns_all_templates ( expect , client ) : request , response = client . get ( \"/templates\" ) expect ( response . status ) == 200","title":"describe_template_list"},{"location":"reference/app/tests/test_docs/","text":"Module app.tests.test_docs View Source from pkg_resources import get_distribution def describe_spec (): def it_contains_the_version ( expect , client ): version = get_distribution ( \"memegen\" ) . version request , response = client . get ( \"/docs/swagger.json\" ) expect ( response . status ) == 200 expect ( response . json [ \"info\" ][ \"version\" ]) == version def describe_image_list (): # Only spot checking the POST /images route, not sure # how valuable it would be to check the rest exhaustively? def it_contains_the_operation_id ( expect , client ): request , response = client . get ( \"/docs/swagger.json\" ) # This is our custom operationId, the default was images.index expect ( response . json [ \"paths\" ][ \"/images\" ][ \"post\" ][ \"operationId\" ] ) == \"images.create\" def it_contains_the_request_spec ( expect , client ): request , response = client . get ( \"/docs/swagger.json\" ) request_spec = response . json [ \"paths\" ][ \"/images\" ][ \"post\" ] expect ( request_spec [ \"consumes\" ]) == [ \"application/json\" ] expect ( request_spec [ \"parameters\" ][ 0 ]) == { \"schema\" : { \"type\" : \"object\" , \"properties\" : { \"template_key\" : { \"type\" : \"string\" }, \"text_lines\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"string\" }}, \"extension\" : { \"type\" : \"string\" }, \"redirect\" : { \"type\" : \"boolean\" }, }, }, \"name\" : \"body\" , \"required\" : False , \"in\" : \"body\" , } def it_contains_the_response_spec ( expect , client ): request , response = client . get ( \"/docs/swagger.json\" ) response_spec = response . json [ \"paths\" ][ \"/images\" ][ \"post\" ][ \"responses\" ] # Successful response expect ( response_spec [ \"201\" ][ \"description\" ]) == ( \"Successfully created a meme\" ) expect ( response_spec [ \"201\" ][ \"schema\" ]) == { \"type\" : \"object\" , \"properties\" : { \"url\" : { \"type\" : \"string\" }, }, } # Error response expect ( response_spec [ \"400\" ][ \"description\" ]) == ( 'Required \"template_key\" missing in request body' ) expect ( response_spec [ \"400\" ][ \"schema\" ]) == { \"type\" : \"object\" , \"properties\" : { \"error\" : { \"type\" : \"string\" }, }, } Functions describe_spec def describe_spec ( ) View Source def describe_spec (): def it_contains_the_version ( expect , client ): version = get_distribution ( \"memegen\" ). version request , response = client . get ( \"/docs/swagger.json\" ) expect ( response . status ) == 200 expect ( response . json [ \"info\" ][ \"version\" ]) == version def describe_image_list (): # Only spot checking the POST / images route , not sure # how valuable it would be to check the rest exhaustively ? def it_contains_the_operation_id ( expect , client ): request , response = client . get ( \"/docs/swagger.json\" ) # This is our custom operationId , the default was images . index expect ( response . json [ \"paths\" ][ \"/images\" ][ \"post\" ][ \"operationId\" ] ) == \"images.create\" def it_contains_the_request_spec ( expect , client ): request , response = client . get ( \"/docs/swagger.json\" ) request_spec = response . json [ \"paths\" ][ \"/images\" ][ \"post\" ] expect ( request_spec [ \"consumes\" ]) == [ \"application/json\" ] expect ( request_spec [ \"parameters\" ][ 0 ]) == { \"schema\" : { \"type\" : \"object\" , \"properties\" : { \"template_key\" : { \"type\" : \"string\" } , \"text_lines\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"string\" }} , \"extension\" : { \"type\" : \"string\" } , \"redirect\" : { \"type\" : \"boolean\" } , } , } , \"name\" : \"body\" , \"required\" : False , \"in\" : \"body\" , } def it_contains_the_response_spec ( expect , client ): request , response = client . get ( \"/docs/swagger.json\" ) response_spec = response . json [ \"paths\" ][ \"/images\" ][ \"post\" ][ \"responses\" ] # Successful response expect ( response_spec [ \"201\" ][ \"description\" ]) == ( \"Successfully created a meme\" ) expect ( response_spec [ \"201\" ][ \"schema\" ]) == { \"type\" : \"object\" , \"properties\" : { \"url\" : { \"type\" : \"string\" } , } , } # Error response expect ( response_spec [ \"400\" ][ \"description\" ]) == ( 'Required \"template_key\" missing in request body' ) expect ( response_spec [ \"400\" ][ \"schema\" ]) == { \"type\" : \"object\" , \"properties\" : { \"error\" : { \"type\" : \"string\" } , } , }","title":"Test Docs"},{"location":"reference/app/tests/test_docs/#module-appteststest_docs","text":"View Source from pkg_resources import get_distribution def describe_spec (): def it_contains_the_version ( expect , client ): version = get_distribution ( \"memegen\" ) . version request , response = client . get ( \"/docs/swagger.json\" ) expect ( response . status ) == 200 expect ( response . json [ \"info\" ][ \"version\" ]) == version def describe_image_list (): # Only spot checking the POST /images route, not sure # how valuable it would be to check the rest exhaustively? def it_contains_the_operation_id ( expect , client ): request , response = client . get ( \"/docs/swagger.json\" ) # This is our custom operationId, the default was images.index expect ( response . json [ \"paths\" ][ \"/images\" ][ \"post\" ][ \"operationId\" ] ) == \"images.create\" def it_contains_the_request_spec ( expect , client ): request , response = client . get ( \"/docs/swagger.json\" ) request_spec = response . json [ \"paths\" ][ \"/images\" ][ \"post\" ] expect ( request_spec [ \"consumes\" ]) == [ \"application/json\" ] expect ( request_spec [ \"parameters\" ][ 0 ]) == { \"schema\" : { \"type\" : \"object\" , \"properties\" : { \"template_key\" : { \"type\" : \"string\" }, \"text_lines\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"string\" }}, \"extension\" : { \"type\" : \"string\" }, \"redirect\" : { \"type\" : \"boolean\" }, }, }, \"name\" : \"body\" , \"required\" : False , \"in\" : \"body\" , } def it_contains_the_response_spec ( expect , client ): request , response = client . get ( \"/docs/swagger.json\" ) response_spec = response . json [ \"paths\" ][ \"/images\" ][ \"post\" ][ \"responses\" ] # Successful response expect ( response_spec [ \"201\" ][ \"description\" ]) == ( \"Successfully created a meme\" ) expect ( response_spec [ \"201\" ][ \"schema\" ]) == { \"type\" : \"object\" , \"properties\" : { \"url\" : { \"type\" : \"string\" }, }, } # Error response expect ( response_spec [ \"400\" ][ \"description\" ]) == ( 'Required \"template_key\" missing in request body' ) expect ( response_spec [ \"400\" ][ \"schema\" ]) == { \"type\" : \"object\" , \"properties\" : { \"error\" : { \"type\" : \"string\" }, }, }","title":"Module app.tests.test_docs"},{"location":"reference/app/tests/test_docs/#functions","text":"","title":"Functions"},{"location":"reference/app/tests/test_docs/#describe_spec","text":"def describe_spec ( ) View Source def describe_spec (): def it_contains_the_version ( expect , client ): version = get_distribution ( \"memegen\" ). version request , response = client . get ( \"/docs/swagger.json\" ) expect ( response . status ) == 200 expect ( response . json [ \"info\" ][ \"version\" ]) == version def describe_image_list (): # Only spot checking the POST / images route , not sure # how valuable it would be to check the rest exhaustively ? def it_contains_the_operation_id ( expect , client ): request , response = client . get ( \"/docs/swagger.json\" ) # This is our custom operationId , the default was images . index expect ( response . json [ \"paths\" ][ \"/images\" ][ \"post\" ][ \"operationId\" ] ) == \"images.create\" def it_contains_the_request_spec ( expect , client ): request , response = client . get ( \"/docs/swagger.json\" ) request_spec = response . json [ \"paths\" ][ \"/images\" ][ \"post\" ] expect ( request_spec [ \"consumes\" ]) == [ \"application/json\" ] expect ( request_spec [ \"parameters\" ][ 0 ]) == { \"schema\" : { \"type\" : \"object\" , \"properties\" : { \"template_key\" : { \"type\" : \"string\" } , \"text_lines\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"string\" }} , \"extension\" : { \"type\" : \"string\" } , \"redirect\" : { \"type\" : \"boolean\" } , } , } , \"name\" : \"body\" , \"required\" : False , \"in\" : \"body\" , } def it_contains_the_response_spec ( expect , client ): request , response = client . get ( \"/docs/swagger.json\" ) response_spec = response . json [ \"paths\" ][ \"/images\" ][ \"post\" ][ \"responses\" ] # Successful response expect ( response_spec [ \"201\" ][ \"description\" ]) == ( \"Successfully created a meme\" ) expect ( response_spec [ \"201\" ][ \"schema\" ]) == { \"type\" : \"object\" , \"properties\" : { \"url\" : { \"type\" : \"string\" } , } , } # Error response expect ( response_spec [ \"400\" ][ \"description\" ]) == ( 'Required \"template_key\" missing in request body' ) expect ( response_spec [ \"400\" ][ \"schema\" ]) == { \"type\" : \"object\" , \"properties\" : { \"error\" : { \"type\" : \"string\" } , } , }","title":"describe_spec"},{"location":"reference/app/tests/test_images/","text":"Module app.tests.test_images View Source import os import shutil import time from pathlib import Path import pytest from .. import models , settings , utils @pytest.fixture ( scope = \"session\" ) def images (): path = settings . TEST_IMAGES_DIRECTORY flag = path / \".flag\" if flag . exists (): age = time . time () - flag . stat () . st_mtime if age > 60 * 60 * 6 and \"SKIP_SLOW\" not in os . environ : shutil . rmtree ( path ) path . mkdir ( exist_ok = True ) flag . touch () return path @pytest.fixture ( scope = \"session\" ) def template (): return models . Template . objects . get ( \"icanhas\" ) # Formats @pytest.mark.parametrize (( \"key\" , \"lines\" ), settings . TEST_IMAGES ) def test_png_images ( images , key , lines ): template = models . Template . objects . get ( key ) utils . images . save ( template , lines , \"png\" , directory = images ) def test_jpg_images ( images ): key , lines = settings . TEST_IMAGES [ 0 ] template = models . Template . objects . get ( key ) utils . images . save ( template , lines , \"jpg\" , directory = images ) # Size def test_smaller_width ( images , template ): utils . images . save ( template , [ \"width=250\" ], size = ( 250 , 0 ), directory = images ) def test_smaller_height ( images , template ): utils . images . save ( template , [ \"height=250\" ], size = ( 0 , 250 ), directory = images ) def test_larger_width ( images , template ): utils . images . save ( template , [ \"width=500\" ], size = ( 500 , 0 ), directory = images ) def test_larger_height ( images , template ): utils . images . save ( template , [ \"height=500\" ], size = ( 0 , 500 ), directory = images ) def test_padding ( images , template ): lines = [ \"width=500\" , \"height=500\" ] utils . images . save ( template , lines , size = ( 500 , 500 ), directory = images ) def test_small_padding ( images , template ): lines = [ \"width=50\" , \"height=50\" ] utils . images . save ( template , lines , size = ( 50 , 50 ), directory = images ) @pytest.mark.slow def test_large_padding ( images , template ): lines = [ \"width=2000\" , \"height=2000\" ] utils . images . save ( template , lines , size = ( 2000 , 2000 ), directory = images ) # Templates @pytest.mark.asyncio async def test_custom_template ( images ): url = \"https://www.gstatic.com/webp/gallery/2.jpg\" template = await models . Template . create ( url ) utils . images . save ( template , [ \"\" , \"My Custom Template\" ], directory = images ) @pytest.mark.slow @pytest.mark.asyncio async def test_custom_template_with_exif_rotation ( images ): url = \"https://cdn.discordapp.com/attachments/752902976322142218/752903391281283152/20200608_111430.jpg\" template = await models . Template . create ( url ) utils . images . save ( template , [ \"\" , \"This should not be rotated!\" ], directory = images ) def test_unknown_template ( images ): template = models . Template . objects . get ( \"_error\" ) utils . images . save ( template , [ \"UNKNOWN TEMPLATE\" ], directory = images ) # Styles def test_style ( images ): template = models . Template . objects . get ( \"ds\" ) lines = [ \"one\" , \"two\" , \"three\" ] utils . images . save ( template , lines , style = \"maga\" , directory = images ) # Text def test_special_characters ( images , template ): lines = [ \"Special? 100% #these-memes\" , \"template_rating: 9/10\" ] utils . images . save ( template , lines , directory = images ) @pytest.mark.skipif ( \"CIRCLECI\" in os . environ , reason = \"Long filenames not supported\" ) def test_extremely_long_text ( images , tmpdir ): template = models . Template . objects . get ( \"fry\" ) lines = [ \"\" , \"word \" * 40 ] utils . images . save ( template , lines , directory = Path ( tmpdir ) / \"images\" ) def test_long_first_word ( images ): template = models . Template . objects . get ( \"fine\" ) lines = [ \"\" , \"thiiiiiiiiiiiiiiiiiiiiis will probably be fine right now\" ] utils . images . save ( template , lines , directory = images ) def test_text_wrap_when_font_is_too_small ( images ): template = models . Template . objects . get ( \"ds\" ) lines = [ \"this button seems to be ok to push\" ] utils . images . save ( template , lines , directory = images ) @pytest.mark.slow def test_descender_vertical_alignment ( images ): template = models . Template . objects . get ( \"ptj\" ) lines = [ \"Exit\" , \"Exit\" , \"the\" , \"the\" , \"monorepo\" , \"monorepo\" , \"Exit the monorepo.\" , \"Stop testing!\" , ] utils . images . save ( template , lines , directory = images ) # Debug def test_debug_images ( images , monkeypatch ): monkeypatch . setattr ( settings , \"DEBUG\" , True ) key , lines = settings . TEST_IMAGES [ 0 ] template = models . Template . objects . get ( key ) lines = [ lines [ 0 ], lines [ 1 ] + \" (debug)\" ] utils . images . save ( template , lines , directory = images ) Functions images def images ( ) View Source @pytest . fixture ( scope = \"session\" ) def images () : path = settings . TEST_IMAGES_DIRECTORY flag = path / \".flag\" if flag . exists () : age = time . time () - flag . stat (). st_mtime if age > 60 * 60 * 6 and \"SKIP_SLOW\" not in os . environ : shutil . rmtree ( path ) path . mkdir ( exist_ok = True ) flag . touch () return path template def template ( ) View Source @pytest . fixture ( scope = \"session\" ) def template () : return models . Template . objects . get ( \"icanhas\" ) test_custom_template def test_custom_template ( images ) View Source @pytest . mark . asyncio async def test_custom_template ( images ) : url = \"https://www.gstatic.com/webp/gallery/2.jpg\" template = await models . Template . create ( url ) utils . images . save ( template , [ \"\", \"My Custom Template\" ] , directory = images ) test_custom_template_with_exif_rotation def test_custom_template_with_exif_rotation ( images ) View Source @pytest . mark . slow @pytest . mark . asyncio async def test_custom_template_with_exif_rotation ( images ) : url = \"https://cdn.discordapp.com/attachments/752902976322142218/752903391281283152/20200608_111430.jpg\" template = await models . Template . create ( url ) utils . images . save ( template , [ \"\", \"This should not be rotated!\" ] , directory = images ) test_debug_images def test_debug_images ( images , monkeypatch ) View Source def test_debug_images ( images , monkeypatch ): monkeypatch . setattr ( settings , \"DEBUG\" , True ) key , lines = settings . TEST_IMAGES [ 0 ] template = models . Template . objects . get ( key ) lines = [ lines [ 0 ], lines [ 1 ] + \" (debug)\" ] utils . images . save ( template , lines , directory = images ) test_descender_vertical_alignment def test_descender_vertical_alignment ( images ) View Source @pytest . mark . slow def test_descender_vertical_alignment ( images ) : template = models . Template . objects . get ( \"ptj\" ) lines = [ \"Exit\", \"Exit\", \"the\", \"the\", \"monorepo\", \"monorepo\", \"Exit the monorepo.\", \"Stop testing!\", ] utils . images . save ( template , lines , directory = images ) test_extremely_long_text def test_extremely_long_text ( images , tmpdir ) View Source @pytest . mark . skipif ( \"CIRCLECI\" in os . environ , reason = \"Long filenames not supported\" ) def test_extremely_long_text ( images , tmpdir ) : template = models . Template . objects . get ( \"fry\" ) lines = [ \"\", \"word \" * 40 ] utils . images . save ( template , lines , directory = Path ( tmpdir ) / \"images\" ) test_jpg_images def test_jpg_images ( images ) View Source def test_jpg_images ( images ): key , lines = settings . TEST_IMAGES [ 0 ] template = models . Template . objects . get ( key ) utils . images . save ( template , lines , \"jpg\" , directory = images ) test_large_padding def test_large_padding ( images , template ) View Source @pytest . mark . slow def test_large_padding ( images , template ) : lines = [ \"width=2000\", \"height=2000\" ] utils . images . save ( template , lines , size = ( 2000 , 2000 ), directory = images ) test_larger_height def test_larger_height ( images , template ) View Source def test_larger_height ( images , template ): utils . images . save ( template , [ \"height=500\" ], size = ( 0 , 500 ), directory = images ) test_larger_width def test_larger_width ( images , template ) View Source def test_larger_width ( images , template ): utils . images . save ( template , [ \"width=500\" ], size = ( 500 , 0 ), directory = images ) test_long_first_word def test_long_first_word ( images ) View Source def test_long_first_word ( images ): template = models . Template . objects . get ( \"fine\" ) lines = [ \"\" , \"thiiiiiiiiiiiiiiiiiiiiis will probably be fine right now\" ] utils . images . save ( template , lines , directory = images ) test_padding def test_padding ( images , template ) View Source def test_padding ( images , template ): lines = [ \"width=500\" , \"height=500\" ] utils . images . save ( template , lines , size = ( 500 , 500 ), directory = images ) test_png_images def test_png_images ( images , key , lines ) View Source @pytest . mark . parametrize (( \"key\" , \"lines\" ), settings . TEST_IMAGES ) def test_png_images ( images , key , lines ) : template = models . Template . objects . get ( key ) utils . images . save ( template , lines , \"png\" , directory = images ) test_small_padding def test_small_padding ( images , template ) View Source def test_small_padding ( images , template ): lines = [ \"width=50\" , \"height=50\" ] utils . images . save ( template , lines , size = ( 50 , 50 ), directory = images ) test_smaller_height def test_smaller_height ( images , template ) View Source def test_smaller_height ( images , template ): utils . images . save ( template , [ \"height=250\" ], size = ( 0 , 250 ), directory = images ) test_smaller_width def test_smaller_width ( images , template ) View Source def test_smaller_width ( images , template ): utils . images . save ( template , [ \"width=250\" ], size = ( 250 , 0 ), directory = images ) test_special_characters def test_special_characters ( images , template ) View Source def test_special_characters ( images , template ): lines = [ \"Special? 100% #these-memes\" , \"template_rating: 9/10\" ] utils . images . save ( template , lines , directory = images ) test_style def test_style ( images ) View Source def test_style ( images ): template = models . Template . objects . get ( \"ds\" ) lines = [ \"one\" , \"two\" , \"three\" ] utils . images . save ( template , lines , style = \"maga\" , directory = images ) test_text_wrap_when_font_is_too_small def test_text_wrap_when_font_is_too_small ( images ) View Source def test_text_wrap_when_font_is_too_small ( images ): template = models . Template . objects . get ( \"ds\" ) lines = [ \"this button seems to be ok to push\" ] utils . images . save ( template , lines , directory = images ) test_unknown_template def test_unknown_template ( images ) View Source def test_unknown_template ( images ): template = models . Template . objects . get ( \"_error\" ) utils . images . save ( template , [ \"UNKNOWN TEMPLATE\" ], directory = images )","title":"Test Images"},{"location":"reference/app/tests/test_images/#module-appteststest_images","text":"View Source import os import shutil import time from pathlib import Path import pytest from .. import models , settings , utils @pytest.fixture ( scope = \"session\" ) def images (): path = settings . TEST_IMAGES_DIRECTORY flag = path / \".flag\" if flag . exists (): age = time . time () - flag . stat () . st_mtime if age > 60 * 60 * 6 and \"SKIP_SLOW\" not in os . environ : shutil . rmtree ( path ) path . mkdir ( exist_ok = True ) flag . touch () return path @pytest.fixture ( scope = \"session\" ) def template (): return models . Template . objects . get ( \"icanhas\" ) # Formats @pytest.mark.parametrize (( \"key\" , \"lines\" ), settings . TEST_IMAGES ) def test_png_images ( images , key , lines ): template = models . Template . objects . get ( key ) utils . images . save ( template , lines , \"png\" , directory = images ) def test_jpg_images ( images ): key , lines = settings . TEST_IMAGES [ 0 ] template = models . Template . objects . get ( key ) utils . images . save ( template , lines , \"jpg\" , directory = images ) # Size def test_smaller_width ( images , template ): utils . images . save ( template , [ \"width=250\" ], size = ( 250 , 0 ), directory = images ) def test_smaller_height ( images , template ): utils . images . save ( template , [ \"height=250\" ], size = ( 0 , 250 ), directory = images ) def test_larger_width ( images , template ): utils . images . save ( template , [ \"width=500\" ], size = ( 500 , 0 ), directory = images ) def test_larger_height ( images , template ): utils . images . save ( template , [ \"height=500\" ], size = ( 0 , 500 ), directory = images ) def test_padding ( images , template ): lines = [ \"width=500\" , \"height=500\" ] utils . images . save ( template , lines , size = ( 500 , 500 ), directory = images ) def test_small_padding ( images , template ): lines = [ \"width=50\" , \"height=50\" ] utils . images . save ( template , lines , size = ( 50 , 50 ), directory = images ) @pytest.mark.slow def test_large_padding ( images , template ): lines = [ \"width=2000\" , \"height=2000\" ] utils . images . save ( template , lines , size = ( 2000 , 2000 ), directory = images ) # Templates @pytest.mark.asyncio async def test_custom_template ( images ): url = \"https://www.gstatic.com/webp/gallery/2.jpg\" template = await models . Template . create ( url ) utils . images . save ( template , [ \"\" , \"My Custom Template\" ], directory = images ) @pytest.mark.slow @pytest.mark.asyncio async def test_custom_template_with_exif_rotation ( images ): url = \"https://cdn.discordapp.com/attachments/752902976322142218/752903391281283152/20200608_111430.jpg\" template = await models . Template . create ( url ) utils . images . save ( template , [ \"\" , \"This should not be rotated!\" ], directory = images ) def test_unknown_template ( images ): template = models . Template . objects . get ( \"_error\" ) utils . images . save ( template , [ \"UNKNOWN TEMPLATE\" ], directory = images ) # Styles def test_style ( images ): template = models . Template . objects . get ( \"ds\" ) lines = [ \"one\" , \"two\" , \"three\" ] utils . images . save ( template , lines , style = \"maga\" , directory = images ) # Text def test_special_characters ( images , template ): lines = [ \"Special? 100% #these-memes\" , \"template_rating: 9/10\" ] utils . images . save ( template , lines , directory = images ) @pytest.mark.skipif ( \"CIRCLECI\" in os . environ , reason = \"Long filenames not supported\" ) def test_extremely_long_text ( images , tmpdir ): template = models . Template . objects . get ( \"fry\" ) lines = [ \"\" , \"word \" * 40 ] utils . images . save ( template , lines , directory = Path ( tmpdir ) / \"images\" ) def test_long_first_word ( images ): template = models . Template . objects . get ( \"fine\" ) lines = [ \"\" , \"thiiiiiiiiiiiiiiiiiiiiis will probably be fine right now\" ] utils . images . save ( template , lines , directory = images ) def test_text_wrap_when_font_is_too_small ( images ): template = models . Template . objects . get ( \"ds\" ) lines = [ \"this button seems to be ok to push\" ] utils . images . save ( template , lines , directory = images ) @pytest.mark.slow def test_descender_vertical_alignment ( images ): template = models . Template . objects . get ( \"ptj\" ) lines = [ \"Exit\" , \"Exit\" , \"the\" , \"the\" , \"monorepo\" , \"monorepo\" , \"Exit the monorepo.\" , \"Stop testing!\" , ] utils . images . save ( template , lines , directory = images ) # Debug def test_debug_images ( images , monkeypatch ): monkeypatch . setattr ( settings , \"DEBUG\" , True ) key , lines = settings . TEST_IMAGES [ 0 ] template = models . Template . objects . get ( key ) lines = [ lines [ 0 ], lines [ 1 ] + \" (debug)\" ] utils . images . save ( template , lines , directory = images )","title":"Module app.tests.test_images"},{"location":"reference/app/tests/test_images/#functions","text":"","title":"Functions"},{"location":"reference/app/tests/test_images/#images","text":"def images ( ) View Source @pytest . fixture ( scope = \"session\" ) def images () : path = settings . TEST_IMAGES_DIRECTORY flag = path / \".flag\" if flag . exists () : age = time . time () - flag . stat (). st_mtime if age > 60 * 60 * 6 and \"SKIP_SLOW\" not in os . environ : shutil . rmtree ( path ) path . mkdir ( exist_ok = True ) flag . touch () return path","title":"images"},{"location":"reference/app/tests/test_images/#template","text":"def template ( ) View Source @pytest . fixture ( scope = \"session\" ) def template () : return models . Template . objects . get ( \"icanhas\" )","title":"template"},{"location":"reference/app/tests/test_images/#test_custom_template","text":"def test_custom_template ( images ) View Source @pytest . mark . asyncio async def test_custom_template ( images ) : url = \"https://www.gstatic.com/webp/gallery/2.jpg\" template = await models . Template . create ( url ) utils . images . save ( template , [ \"\", \"My Custom Template\" ] , directory = images )","title":"test_custom_template"},{"location":"reference/app/tests/test_images/#test_custom_template_with_exif_rotation","text":"def test_custom_template_with_exif_rotation ( images ) View Source @pytest . mark . slow @pytest . mark . asyncio async def test_custom_template_with_exif_rotation ( images ) : url = \"https://cdn.discordapp.com/attachments/752902976322142218/752903391281283152/20200608_111430.jpg\" template = await models . Template . create ( url ) utils . images . save ( template , [ \"\", \"This should not be rotated!\" ] , directory = images )","title":"test_custom_template_with_exif_rotation"},{"location":"reference/app/tests/test_images/#test_debug_images","text":"def test_debug_images ( images , monkeypatch ) View Source def test_debug_images ( images , monkeypatch ): monkeypatch . setattr ( settings , \"DEBUG\" , True ) key , lines = settings . TEST_IMAGES [ 0 ] template = models . Template . objects . get ( key ) lines = [ lines [ 0 ], lines [ 1 ] + \" (debug)\" ] utils . images . save ( template , lines , directory = images )","title":"test_debug_images"},{"location":"reference/app/tests/test_images/#test_descender_vertical_alignment","text":"def test_descender_vertical_alignment ( images ) View Source @pytest . mark . slow def test_descender_vertical_alignment ( images ) : template = models . Template . objects . get ( \"ptj\" ) lines = [ \"Exit\", \"Exit\", \"the\", \"the\", \"monorepo\", \"monorepo\", \"Exit the monorepo.\", \"Stop testing!\", ] utils . images . save ( template , lines , directory = images )","title":"test_descender_vertical_alignment"},{"location":"reference/app/tests/test_images/#test_extremely_long_text","text":"def test_extremely_long_text ( images , tmpdir ) View Source @pytest . mark . skipif ( \"CIRCLECI\" in os . environ , reason = \"Long filenames not supported\" ) def test_extremely_long_text ( images , tmpdir ) : template = models . Template . objects . get ( \"fry\" ) lines = [ \"\", \"word \" * 40 ] utils . images . save ( template , lines , directory = Path ( tmpdir ) / \"images\" )","title":"test_extremely_long_text"},{"location":"reference/app/tests/test_images/#test_jpg_images","text":"def test_jpg_images ( images ) View Source def test_jpg_images ( images ): key , lines = settings . TEST_IMAGES [ 0 ] template = models . Template . objects . get ( key ) utils . images . save ( template , lines , \"jpg\" , directory = images )","title":"test_jpg_images"},{"location":"reference/app/tests/test_images/#test_large_padding","text":"def test_large_padding ( images , template ) View Source @pytest . mark . slow def test_large_padding ( images , template ) : lines = [ \"width=2000\", \"height=2000\" ] utils . images . save ( template , lines , size = ( 2000 , 2000 ), directory = images )","title":"test_large_padding"},{"location":"reference/app/tests/test_images/#test_larger_height","text":"def test_larger_height ( images , template ) View Source def test_larger_height ( images , template ): utils . images . save ( template , [ \"height=500\" ], size = ( 0 , 500 ), directory = images )","title":"test_larger_height"},{"location":"reference/app/tests/test_images/#test_larger_width","text":"def test_larger_width ( images , template ) View Source def test_larger_width ( images , template ): utils . images . save ( template , [ \"width=500\" ], size = ( 500 , 0 ), directory = images )","title":"test_larger_width"},{"location":"reference/app/tests/test_images/#test_long_first_word","text":"def test_long_first_word ( images ) View Source def test_long_first_word ( images ): template = models . Template . objects . get ( \"fine\" ) lines = [ \"\" , \"thiiiiiiiiiiiiiiiiiiiiis will probably be fine right now\" ] utils . images . save ( template , lines , directory = images )","title":"test_long_first_word"},{"location":"reference/app/tests/test_images/#test_padding","text":"def test_padding ( images , template ) View Source def test_padding ( images , template ): lines = [ \"width=500\" , \"height=500\" ] utils . images . save ( template , lines , size = ( 500 , 500 ), directory = images )","title":"test_padding"},{"location":"reference/app/tests/test_images/#test_png_images","text":"def test_png_images ( images , key , lines ) View Source @pytest . mark . parametrize (( \"key\" , \"lines\" ), settings . TEST_IMAGES ) def test_png_images ( images , key , lines ) : template = models . Template . objects . get ( key ) utils . images . save ( template , lines , \"png\" , directory = images )","title":"test_png_images"},{"location":"reference/app/tests/test_images/#test_small_padding","text":"def test_small_padding ( images , template ) View Source def test_small_padding ( images , template ): lines = [ \"width=50\" , \"height=50\" ] utils . images . save ( template , lines , size = ( 50 , 50 ), directory = images )","title":"test_small_padding"},{"location":"reference/app/tests/test_images/#test_smaller_height","text":"def test_smaller_height ( images , template ) View Source def test_smaller_height ( images , template ): utils . images . save ( template , [ \"height=250\" ], size = ( 0 , 250 ), directory = images )","title":"test_smaller_height"},{"location":"reference/app/tests/test_images/#test_smaller_width","text":"def test_smaller_width ( images , template ) View Source def test_smaller_width ( images , template ): utils . images . save ( template , [ \"width=250\" ], size = ( 250 , 0 ), directory = images )","title":"test_smaller_width"},{"location":"reference/app/tests/test_images/#test_special_characters","text":"def test_special_characters ( images , template ) View Source def test_special_characters ( images , template ): lines = [ \"Special? 100% #these-memes\" , \"template_rating: 9/10\" ] utils . images . save ( template , lines , directory = images )","title":"test_special_characters"},{"location":"reference/app/tests/test_images/#test_style","text":"def test_style ( images ) View Source def test_style ( images ): template = models . Template . objects . get ( \"ds\" ) lines = [ \"one\" , \"two\" , \"three\" ] utils . images . save ( template , lines , style = \"maga\" , directory = images )","title":"test_style"},{"location":"reference/app/tests/test_images/#test_text_wrap_when_font_is_too_small","text":"def test_text_wrap_when_font_is_too_small ( images ) View Source def test_text_wrap_when_font_is_too_small ( images ): template = models . Template . objects . get ( \"ds\" ) lines = [ \"this button seems to be ok to push\" ] utils . images . save ( template , lines , directory = images )","title":"test_text_wrap_when_font_is_too_small"},{"location":"reference/app/tests/test_images/#test_unknown_template","text":"def test_unknown_template ( images ) View Source def test_unknown_template ( images ): template = models . Template . objects . get ( \"_error\" ) utils . images . save ( template , [ \"UNKNOWN TEMPLATE\" ], directory = images )","title":"test_unknown_template"},{"location":"reference/app/tests/test_models/","text":"Module app.tests.test_models View Source from pathlib import Path import log import pytest from .. import settings from ..models import Template , Text def describe_text (): def describe_stylize (): @pytest.mark.parametrize ( ( \"style\" , \"before\" , \"after\" ), [ ( \"none\" , \"Hello, world!\" , \"Hello, world!\" ), ( \"default\" , \"these are words.\" , \"These are words.\" ), ( \"default\" , \"These ARE words.\" , \"These ARE words.\" ), ( \"upper\" , \"Hello, world!\" , \"HELLO, WORLD!\" ), ( \"lower\" , \"Hello, world!\" , \"hello, world!\" ), ( \"title\" , \"these are words\" , \"These Are Words\" ), ( \"capitalize\" , \"these are words\" , \"These are words\" ), ( \"mock\" , \"these are words\" , \"ThEsE aRe WorDs\" ), ( \"<unknown>\" , \"Hello, world!\" , \"Hello, world!\" ), ], ) def it_applies_style ( expect , style , before , after ): text = Text () text . style = style expect ( text . stylize ( before )) == after def it_defaults_to_upper ( expect ): text = Text () text . style = \"\" expect ( text . stylize ( \"Foobar\" )) == \"FOOBAR\" def describe_template (): @pytest.fixture def template (): return Template . objects . get ( \"_test\" ) def describe_str (): def it_includes_the_path ( expect , template ): expect ( str ( template )) . endswith ( \"/memegen/templates/_test\" ) def describe_text (): def it_defaults_to_two_lines ( expect , template ): expect ( template . text ) == [ Text (), Text ( anchor_x = 0.0 , anchor_y = 0.8 )] def describe_image (): def it_has_generic_extension_when_absent ( expect , template ): expect ( template . image ) == Path . cwd () / \"templates\" / \"_test\" / \"default.img\" def it_creates_template_directory_automatically ( expect ): template = Template . objects . get_or_create ( \"_custom-empty\" ) template . datafile . path . unlink () template . datafile . path . parent . rmdir () log . info ( template . image ) expect ( template . datafile . path . parent . exists ()) == True def describe_create (): @pytest.mark.asyncio async def it_downloads_the_image ( expect , monkeypatch ): monkeypatch . setattr ( settings , \"DEBUG\" , True ) url = \"https://www.gstatic.com/webp/gallery/1.jpg\" path = ( Path . cwd () / \"templates\" / \"_custom-2d3c91e23b91d6387050e85efc1f3acb39b5a95d\" / \"default.img\" ) template = await Template . create ( url ) expect ( template . image ) == path expect ( template . image . exists ()) == True @pytest.mark.asyncio async def it_handles_misssing_urls ( expect ): url = \"http://example.com/does_not_exist.png\" template = await Template . create ( url ) expect ( template . image . exists ()) == False @pytest.mark.asyncio async def it_handles_invalid_urls ( expect ): url = \"http://127.0.0.1/does_not_exist.png\" template = await Template . create ( url ) expect ( template . image . exists ()) == False @pytest.mark.asyncio async def it_rejects_non_images ( expect ): url = \"https://file-examples-com.github.io/uploads/2017/04/file_example_MP4_480_1_5MG.mp4\" template = await Template . create ( url ) expect ( template . image . exists ()) == False @pytest.mark.asyncio async def it_handles_builtin_templates ( expect ): url = \"http://api.memegen.link/images/fry.png\" template = await Template . create ( url ) expect ( template . key ) == \"fry\" @pytest.mark.asyncio async def it_handles_custom_image_urls ( expect ): url = \"http://api.memegen.link/images/fry/test.png\" template = await Template . create ( url ) expect ( template . key ) == \"fry\" Functions describe_template def describe_template ( ) View Source def describe_template (): @ pytest . fixture def template (): return Template . objects . get ( \"_test\" ) def describe_str (): def it_includes_the_path ( expect , template ): expect ( str ( template )) . endswith ( \"/memegen/templates/_test\" ) def describe_text (): def it_defaults_to_two_lines ( expect , template ): expect ( template . text ) == [ Text (), Text ( anchor_x = 0.0 , anchor_y = 0.8 )] def describe_image (): def it_has_generic_extension_when_absent ( expect , template ): expect ( template . image ) == Path . cwd () / \"templates\" / \"_test\" / \"default.img\" def it_creates_template_directory_automatically ( expect ): template = Template . objects . get_or_create ( \"_custom-empty\" ) template . datafile . path . unlink () template . datafile . path . parent . rmdir () log . info ( template . image ) expect ( template . datafile . path . parent . exists ()) == True def describe_create (): @ pytest . mark . asyncio async def it_downloads_the_image ( expect , monkeypatch ): monkeypatch . setattr ( settings , \"DEBUG\" , True ) url = \"https://www.gstatic.com/webp/gallery/1.jpg\" path = ( Path . cwd () / \"templates\" / \"_custom-2d3c91e23b91d6387050e85efc1f3acb39b5a95d\" / \"default.img\" ) template = await Template . create ( url ) expect ( template . image ) == path expect ( template . image . exists ()) == True @ pytest . mark . asyncio async def it_handles_misssing_urls ( expect ): url = \"http://example.com/does_not_exist.png\" template = await Template . create ( url ) expect ( template . image . exists ()) == False @ pytest . mark . asyncio async def it_handles_invalid_urls ( expect ): url = \"http://127.0.0.1/does_not_exist.png\" template = await Template . create ( url ) expect ( template . image . exists ()) == False @ pytest . mark . asyncio async def it_rejects_non_images ( expect ): url = \"https://file-examples-com.github.io/uploads/2017/04/file_example_MP4_480_1_5MG.mp4\" template = await Template . create ( url ) expect ( template . image . exists ()) == False @ pytest . mark . asyncio async def it_handles_builtin_templates ( expect ): url = \"http://api.memegen.link/images/fry.png\" template = await Template . create ( url ) expect ( template . key ) == \"fry\" @ pytest . mark . asyncio async def it_handles_custom_image_urls ( expect ): url = \"http://api.memegen.link/images/fry/test.png\" template = await Template . create ( url ) expect ( template . key ) == \"fry\" describe_text def describe_text ( ) View Source def describe_text () : def describe_stylize () : @pytest . mark . parametrize ( ( \"style\" , \"before\" , \"after\" ), [ (\"none\", \"Hello, world!\", \"Hello, world!\"), (\"default\", \"these are words.\", \"These are words.\"), (\"default\", \"These ARE words.\", \"These ARE words.\"), (\"upper\", \"Hello, world!\", \"HELLO, WORLD!\"), (\"lower\", \"Hello, world!\", \"hello, world!\"), (\"title\", \"these are words\", \"These Are Words\"), (\"capitalize\", \"these are words\", \"These are words\"), (\"mock\", \"these are words\", \"ThEsE aRe WorDs\"), (\"<unknown>\", \"Hello, world!\", \"Hello, world!\"), ] , ) def it_applies_style ( expect , style , before , after ) : text = Text () text . style = style expect ( text . stylize ( before )) == after def it_defaults_to_upper ( expect ) : text = Text () text . style = \"\" expect ( text . stylize ( \"Foobar\" )) == \"FOOBAR\"","title":"Test Models"},{"location":"reference/app/tests/test_models/#module-appteststest_models","text":"View Source from pathlib import Path import log import pytest from .. import settings from ..models import Template , Text def describe_text (): def describe_stylize (): @pytest.mark.parametrize ( ( \"style\" , \"before\" , \"after\" ), [ ( \"none\" , \"Hello, world!\" , \"Hello, world!\" ), ( \"default\" , \"these are words.\" , \"These are words.\" ), ( \"default\" , \"These ARE words.\" , \"These ARE words.\" ), ( \"upper\" , \"Hello, world!\" , \"HELLO, WORLD!\" ), ( \"lower\" , \"Hello, world!\" , \"hello, world!\" ), ( \"title\" , \"these are words\" , \"These Are Words\" ), ( \"capitalize\" , \"these are words\" , \"These are words\" ), ( \"mock\" , \"these are words\" , \"ThEsE aRe WorDs\" ), ( \"<unknown>\" , \"Hello, world!\" , \"Hello, world!\" ), ], ) def it_applies_style ( expect , style , before , after ): text = Text () text . style = style expect ( text . stylize ( before )) == after def it_defaults_to_upper ( expect ): text = Text () text . style = \"\" expect ( text . stylize ( \"Foobar\" )) == \"FOOBAR\" def describe_template (): @pytest.fixture def template (): return Template . objects . get ( \"_test\" ) def describe_str (): def it_includes_the_path ( expect , template ): expect ( str ( template )) . endswith ( \"/memegen/templates/_test\" ) def describe_text (): def it_defaults_to_two_lines ( expect , template ): expect ( template . text ) == [ Text (), Text ( anchor_x = 0.0 , anchor_y = 0.8 )] def describe_image (): def it_has_generic_extension_when_absent ( expect , template ): expect ( template . image ) == Path . cwd () / \"templates\" / \"_test\" / \"default.img\" def it_creates_template_directory_automatically ( expect ): template = Template . objects . get_or_create ( \"_custom-empty\" ) template . datafile . path . unlink () template . datafile . path . parent . rmdir () log . info ( template . image ) expect ( template . datafile . path . parent . exists ()) == True def describe_create (): @pytest.mark.asyncio async def it_downloads_the_image ( expect , monkeypatch ): monkeypatch . setattr ( settings , \"DEBUG\" , True ) url = \"https://www.gstatic.com/webp/gallery/1.jpg\" path = ( Path . cwd () / \"templates\" / \"_custom-2d3c91e23b91d6387050e85efc1f3acb39b5a95d\" / \"default.img\" ) template = await Template . create ( url ) expect ( template . image ) == path expect ( template . image . exists ()) == True @pytest.mark.asyncio async def it_handles_misssing_urls ( expect ): url = \"http://example.com/does_not_exist.png\" template = await Template . create ( url ) expect ( template . image . exists ()) == False @pytest.mark.asyncio async def it_handles_invalid_urls ( expect ): url = \"http://127.0.0.1/does_not_exist.png\" template = await Template . create ( url ) expect ( template . image . exists ()) == False @pytest.mark.asyncio async def it_rejects_non_images ( expect ): url = \"https://file-examples-com.github.io/uploads/2017/04/file_example_MP4_480_1_5MG.mp4\" template = await Template . create ( url ) expect ( template . image . exists ()) == False @pytest.mark.asyncio async def it_handles_builtin_templates ( expect ): url = \"http://api.memegen.link/images/fry.png\" template = await Template . create ( url ) expect ( template . key ) == \"fry\" @pytest.mark.asyncio async def it_handles_custom_image_urls ( expect ): url = \"http://api.memegen.link/images/fry/test.png\" template = await Template . create ( url ) expect ( template . key ) == \"fry\"","title":"Module app.tests.test_models"},{"location":"reference/app/tests/test_models/#functions","text":"","title":"Functions"},{"location":"reference/app/tests/test_models/#describe_template","text":"def describe_template ( ) View Source def describe_template (): @ pytest . fixture def template (): return Template . objects . get ( \"_test\" ) def describe_str (): def it_includes_the_path ( expect , template ): expect ( str ( template )) . endswith ( \"/memegen/templates/_test\" ) def describe_text (): def it_defaults_to_two_lines ( expect , template ): expect ( template . text ) == [ Text (), Text ( anchor_x = 0.0 , anchor_y = 0.8 )] def describe_image (): def it_has_generic_extension_when_absent ( expect , template ): expect ( template . image ) == Path . cwd () / \"templates\" / \"_test\" / \"default.img\" def it_creates_template_directory_automatically ( expect ): template = Template . objects . get_or_create ( \"_custom-empty\" ) template . datafile . path . unlink () template . datafile . path . parent . rmdir () log . info ( template . image ) expect ( template . datafile . path . parent . exists ()) == True def describe_create (): @ pytest . mark . asyncio async def it_downloads_the_image ( expect , monkeypatch ): monkeypatch . setattr ( settings , \"DEBUG\" , True ) url = \"https://www.gstatic.com/webp/gallery/1.jpg\" path = ( Path . cwd () / \"templates\" / \"_custom-2d3c91e23b91d6387050e85efc1f3acb39b5a95d\" / \"default.img\" ) template = await Template . create ( url ) expect ( template . image ) == path expect ( template . image . exists ()) == True @ pytest . mark . asyncio async def it_handles_misssing_urls ( expect ): url = \"http://example.com/does_not_exist.png\" template = await Template . create ( url ) expect ( template . image . exists ()) == False @ pytest . mark . asyncio async def it_handles_invalid_urls ( expect ): url = \"http://127.0.0.1/does_not_exist.png\" template = await Template . create ( url ) expect ( template . image . exists ()) == False @ pytest . mark . asyncio async def it_rejects_non_images ( expect ): url = \"https://file-examples-com.github.io/uploads/2017/04/file_example_MP4_480_1_5MG.mp4\" template = await Template . create ( url ) expect ( template . image . exists ()) == False @ pytest . mark . asyncio async def it_handles_builtin_templates ( expect ): url = \"http://api.memegen.link/images/fry.png\" template = await Template . create ( url ) expect ( template . key ) == \"fry\" @ pytest . mark . asyncio async def it_handles_custom_image_urls ( expect ): url = \"http://api.memegen.link/images/fry/test.png\" template = await Template . create ( url ) expect ( template . key ) == \"fry\"","title":"describe_template"},{"location":"reference/app/tests/test_models/#describe_text","text":"def describe_text ( ) View Source def describe_text () : def describe_stylize () : @pytest . mark . parametrize ( ( \"style\" , \"before\" , \"after\" ), [ (\"none\", \"Hello, world!\", \"Hello, world!\"), (\"default\", \"these are words.\", \"These are words.\"), (\"default\", \"These ARE words.\", \"These ARE words.\"), (\"upper\", \"Hello, world!\", \"HELLO, WORLD!\"), (\"lower\", \"Hello, world!\", \"hello, world!\"), (\"title\", \"these are words\", \"These Are Words\"), (\"capitalize\", \"these are words\", \"These are words\"), (\"mock\", \"these are words\", \"ThEsE aRe WorDs\"), (\"<unknown>\", \"Hello, world!\", \"Hello, world!\"), ] , ) def it_applies_style ( expect , style , before , after ) : text = Text () text . style = style expect ( text . stylize ( before )) == after def it_defaults_to_upper ( expect ) : text = Text () text . style = \"\" expect ( text . stylize ( \"Foobar\" )) == \"FOOBAR\"","title":"describe_text"},{"location":"reference/app/tests/test_text/","text":"Module app.tests.test_text View Source import pytest from .. import utils LINES_SLUG = [ ([ \"hello world\" ], \"hello_world\" ), ([ \"?%#/& \\\\ \" ], \"~q~p~h~s~a~b\" ), ([ \"a/b\" , \"c\" ], \"a~sb/c\" ), ([ \"variable_name\" ], \"variable__name\" ), ([ \"variable-name\" ], \"variable--name\" ), ([ \"foo \\n bar\" ], \"foo~nbar\" ), ([ \"def data() -> Dict\" ], \"def_data()_-->_Dict\" ), ([ 'That \\' s not how \"this\" works' ], \"That's_not_how_''this''_works\" ), ] @pytest.mark.parametrize (( \"lines\" , \"slug\" ), LINES_SLUG ) def test_encode ( expect , lines , slug ): expect ( utils . text . encode ( lines )) == slug @pytest.mark.parametrize (( \"lines\" , \"slug\" ), LINES_SLUG ) def test_decode ( expect , lines , slug ): expect ( utils . text . decode ( slug )) == lines def test_decode_dashes ( expect ): expect ( utils . text . decode ( \"hello-world\" )) == [ \"hello world\" ] Variables LINES_SLUG Functions test_decode def test_decode ( expect , lines , slug ) View Source @pytest . mark . parametrize (( \"lines\" , \"slug\" ), LINES_SLUG ) def test_decode ( expect , lines , slug ) : expect ( utils . text . decode ( slug )) == lines test_decode_dashes def test_decode_dashes ( expect ) View Source def test_decode_dashes ( expect ): expect ( utils . text . decode ( \"hello-world\" )) == [ \"hello world\" ] test_encode def test_encode ( expect , lines , slug ) View Source @pytest . mark . parametrize (( \"lines\" , \"slug\" ), LINES_SLUG ) def test_encode ( expect , lines , slug ) : expect ( utils . text . encode ( lines )) == slug","title":"Test Text"},{"location":"reference/app/tests/test_text/#module-appteststest_text","text":"View Source import pytest from .. import utils LINES_SLUG = [ ([ \"hello world\" ], \"hello_world\" ), ([ \"?%#/& \\\\ \" ], \"~q~p~h~s~a~b\" ), ([ \"a/b\" , \"c\" ], \"a~sb/c\" ), ([ \"variable_name\" ], \"variable__name\" ), ([ \"variable-name\" ], \"variable--name\" ), ([ \"foo \\n bar\" ], \"foo~nbar\" ), ([ \"def data() -> Dict\" ], \"def_data()_-->_Dict\" ), ([ 'That \\' s not how \"this\" works' ], \"That's_not_how_''this''_works\" ), ] @pytest.mark.parametrize (( \"lines\" , \"slug\" ), LINES_SLUG ) def test_encode ( expect , lines , slug ): expect ( utils . text . encode ( lines )) == slug @pytest.mark.parametrize (( \"lines\" , \"slug\" ), LINES_SLUG ) def test_decode ( expect , lines , slug ): expect ( utils . text . decode ( slug )) == lines def test_decode_dashes ( expect ): expect ( utils . text . decode ( \"hello-world\" )) == [ \"hello world\" ]","title":"Module app.tests.test_text"},{"location":"reference/app/tests/test_text/#variables","text":"LINES_SLUG","title":"Variables"},{"location":"reference/app/tests/test_text/#functions","text":"","title":"Functions"},{"location":"reference/app/tests/test_text/#test_decode","text":"def test_decode ( expect , lines , slug ) View Source @pytest . mark . parametrize (( \"lines\" , \"slug\" ), LINES_SLUG ) def test_decode ( expect , lines , slug ) : expect ( utils . text . decode ( slug )) == lines","title":"test_decode"},{"location":"reference/app/tests/test_text/#test_decode_dashes","text":"def test_decode_dashes ( expect ) View Source def test_decode_dashes ( expect ): expect ( utils . text . decode ( \"hello-world\" )) == [ \"hello world\" ]","title":"test_decode_dashes"},{"location":"reference/app/tests/test_text/#test_encode","text":"def test_encode ( expect , lines , slug ) View Source @pytest . mark . parametrize (( \"lines\" , \"slug\" ), LINES_SLUG ) def test_encode ( expect , lines , slug ) : expect ( utils . text . encode ( lines )) == slug","title":"test_encode"},{"location":"reference/app/tests/test_views/","text":"Module app.tests.test_views View Source import pytest from .. import settings def describe_index (): def it_contains_the_readme ( expect , client ): request , response = client . get ( \"/\" ) expect ( response . status ) == 200 expect ( response . text ) . contains ( \"documentation is available here\" ) def describe_samples (): @pytest.mark.slow def it_displays_images ( expect , client ): request , response = client . get ( \"/samples\" ) expect ( response . status ) == 200 expect ( response . text . count ( \"img\" )) > 100 def describe_test (): def it_redirects_to_the_index ( expect , client ): request , response = client . get ( \"/test\" , allow_redirects = False ) expect ( response . status ) == 302 expect ( response . headers [ \"Location\" ]) == \"/\" def it_displays_test_images_when_debug ( expect , client , monkeypatch ): monkeypatch . setattr ( settings , \"DEBUG\" , True ) request , response = client . get ( \"/test\" , allow_redirects = False ) expect ( response . status ) == 200 expect ( response . text . count ( \"img\" )) > 5 expect ( response . text . count ( \"img\" )) < 100 Functions describe_index def describe_index ( ) View Source def describe_index (): def it_contains_the_readme ( expect , client ): request , response = client . get ( \"/\" ) expect ( response . status ) == 200 expect ( response . text ). contains ( \"documentation is available here\" ) describe_samples def describe_samples ( ) View Source def describe_samples () : @pytest . mark . slow def it_displays_images ( expect , client ) : request , response = client . get ( \"/samples\" ) expect ( response . status ) == 200 expect ( response . text . count ( \"img\" )) > 100 describe_test def describe_test ( ) View Source def describe_test (): def it_redirects_to_the_index ( expect , client ): request , response = client . get ( \"/test\" , allow_redirects = False ) expect ( response . status ) == 302 expect ( response . headers [ \"Location\" ]) == \"/\" def it_displays_test_images_when_debug ( expect , client , monkeypatch ): monkeypatch . setattr ( settings , \"DEBUG\" , True ) request , response = client . get ( \"/test\" , allow_redirects = False ) expect ( response . status ) == 200 expect ( response . text . count ( \"img\" )) > 5 expect ( response . text . count ( \"img\" )) < 100","title":"Test Views"},{"location":"reference/app/tests/test_views/#module-appteststest_views","text":"View Source import pytest from .. import settings def describe_index (): def it_contains_the_readme ( expect , client ): request , response = client . get ( \"/\" ) expect ( response . status ) == 200 expect ( response . text ) . contains ( \"documentation is available here\" ) def describe_samples (): @pytest.mark.slow def it_displays_images ( expect , client ): request , response = client . get ( \"/samples\" ) expect ( response . status ) == 200 expect ( response . text . count ( \"img\" )) > 100 def describe_test (): def it_redirects_to_the_index ( expect , client ): request , response = client . get ( \"/test\" , allow_redirects = False ) expect ( response . status ) == 302 expect ( response . headers [ \"Location\" ]) == \"/\" def it_displays_test_images_when_debug ( expect , client , monkeypatch ): monkeypatch . setattr ( settings , \"DEBUG\" , True ) request , response = client . get ( \"/test\" , allow_redirects = False ) expect ( response . status ) == 200 expect ( response . text . count ( \"img\" )) > 5 expect ( response . text . count ( \"img\" )) < 100","title":"Module app.tests.test_views"},{"location":"reference/app/tests/test_views/#functions","text":"","title":"Functions"},{"location":"reference/app/tests/test_views/#describe_index","text":"def describe_index ( ) View Source def describe_index (): def it_contains_the_readme ( expect , client ): request , response = client . get ( \"/\" ) expect ( response . status ) == 200 expect ( response . text ). contains ( \"documentation is available here\" )","title":"describe_index"},{"location":"reference/app/tests/test_views/#describe_samples","text":"def describe_samples ( ) View Source def describe_samples () : @pytest . mark . slow def it_displays_images ( expect , client ) : request , response = client . get ( \"/samples\" ) expect ( response . status ) == 200 expect ( response . text . count ( \"img\" )) > 100","title":"describe_samples"},{"location":"reference/app/tests/test_views/#describe_test","text":"def describe_test ( ) View Source def describe_test (): def it_redirects_to_the_index ( expect , client ): request , response = client . get ( \"/test\" , allow_redirects = False ) expect ( response . status ) == 302 expect ( response . headers [ \"Location\" ]) == \"/\" def it_displays_test_images_when_debug ( expect , client , monkeypatch ): monkeypatch . setattr ( settings , \"DEBUG\" , True ) request , response = client . get ( \"/test\" , allow_redirects = False ) expect ( response . status ) == 200 expect ( response . text . count ( \"img\" )) > 5 expect ( response . text . count ( \"img\" )) < 100","title":"describe_test"},{"location":"reference/app/utils/","text":"Module app.utils View Source from . import html , images , text Sub-modules app.utils.html app.utils.images app.utils.text","title":"Index"},{"location":"reference/app/utils/#module-apputils","text":"View Source from . import html , images , text","title":"Module app.utils"},{"location":"reference/app/utils/#sub-modules","text":"app.utils.html app.utils.images app.utils.text","title":"Sub-modules"},{"location":"reference/app/utils/html/","text":"Module app.utils.html View Source from typing import Iterable def gallery ( urls : Iterable [ str ], * , refresh : bool = False , rate : float = 3.0 ) -> str : lines = [] for href in urls : src = href + ( \"?time=0\" if refresh else \"?width=300&height=300\" ) size = \"\" if refresh else 'width=\"300\" height=\"300\"' lines . append ( f \"\"\" <a href=\"{href}\"> <img src=\"{src}\" loading=\"lazy\" {size} style=\"padding: 5px; max-width: 600px; max-height: 600px\"> </a> \"\"\" ) if refresh : lines . append ( r \"\"\" <script> setInterval(function() { var images = document.images; for (var i=0; i<images.length; i++) { images[i].src = images[i].src.replace( /\\btime=[^&]*/, 'time=' + new Date().getTime() ); } }, {interval}); </script> \"\"\" . replace ( \"{interval}\" , str ( int ( rate * 3000 )) ) ) return \" \\n \" . join ( lines ) . replace ( \" \\n \" + \" \" * 12 , \" \\n \" ) Functions gallery def gallery ( urls : Iterable [ str ], * , refresh : bool = False , rate : float = 3.0 ) -> str View Source def gallery ( urls : Iterable [ str ], * , refresh : bool = False , rate : float = 3.0 ) -> str : lines = [] for href in urls : src = href + ( \"?time=0\" if refresh else \"?width=300&height=300\" ) size = \"\" if refresh else 'width=\"300\" height=\"300\"' lines . append ( f \"\"\" <a href=\"{href}\"> <img src=\"{src}\" loading=\"lazy\" {size} style=\"padding: 5px; max-width: 600px; max-height: 600px\"> </a> \"\"\" ) if refresh : lines . append ( r \"\"\" <script> setInterval(function() { var images = document.images; for (var i=0; i<images.length; i++) { images[i].src = images[i].src.replace( /\\btime=[^&]*/, 'time=' + new Date().getTime() ); } }, {interval}); </script> \"\"\" . replace ( \"{interval}\" , str ( int ( rate * 3000 )) ) ) return \" \\n \" . join ( lines ) . replace ( \" \\n \" + \" \" * 12 , \" \\n \" )","title":"Html"},{"location":"reference/app/utils/html/#module-apputilshtml","text":"View Source from typing import Iterable def gallery ( urls : Iterable [ str ], * , refresh : bool = False , rate : float = 3.0 ) -> str : lines = [] for href in urls : src = href + ( \"?time=0\" if refresh else \"?width=300&height=300\" ) size = \"\" if refresh else 'width=\"300\" height=\"300\"' lines . append ( f \"\"\" <a href=\"{href}\"> <img src=\"{src}\" loading=\"lazy\" {size} style=\"padding: 5px; max-width: 600px; max-height: 600px\"> </a> \"\"\" ) if refresh : lines . append ( r \"\"\" <script> setInterval(function() { var images = document.images; for (var i=0; i<images.length; i++) { images[i].src = images[i].src.replace( /\\btime=[^&]*/, 'time=' + new Date().getTime() ); } }, {interval}); </script> \"\"\" . replace ( \"{interval}\" , str ( int ( rate * 3000 )) ) ) return \" \\n \" . join ( lines ) . replace ( \" \\n \" + \" \" * 12 , \" \\n \" )","title":"Module app.utils.html"},{"location":"reference/app/utils/html/#functions","text":"","title":"Functions"},{"location":"reference/app/utils/html/#gallery","text":"def gallery ( urls : Iterable [ str ], * , refresh : bool = False , rate : float = 3.0 ) -> str View Source def gallery ( urls : Iterable [ str ], * , refresh : bool = False , rate : float = 3.0 ) -> str : lines = [] for href in urls : src = href + ( \"?time=0\" if refresh else \"?width=300&height=300\" ) size = \"\" if refresh else 'width=\"300\" height=\"300\"' lines . append ( f \"\"\" <a href=\"{href}\"> <img src=\"{src}\" loading=\"lazy\" {size} style=\"padding: 5px; max-width: 600px; max-height: 600px\"> </a> \"\"\" ) if refresh : lines . append ( r \"\"\" <script> setInterval(function() { var images = document.images; for (var i=0; i<images.length; i++) { images[i].src = images[i].src.replace( /\\btime=[^&]*/, 'time=' + new Date().getTime() ); } }, {interval}); </script> \"\"\" . replace ( \"{interval}\" , str ( int ( rate * 3000 )) ) ) return \" \\n \" . join ( lines ) . replace ( \" \\n \" + \" \" * 12 , \" \\n \" )","title":"gallery"},{"location":"reference/app/utils/images/","text":"Module app.utils.images View Source from __future__ import annotations import hashlib import io from pathlib import Path from typing import TYPE_CHECKING , Iterator , List , Optional , Tuple from PIL import Image , ImageDraw , ImageFilter , ImageFont , ImageOps from sanic.log import logger from .. import settings from ..types import Dimensions , Offset , Point from .text import encode if TYPE_CHECKING : from ..models import Template def preview ( template : Template , lines : List [ str ], style : str = settings . DEFAULT_STYLE ) -> Tuple [ bytes , str ]: image = render_image ( template , style , lines , settings . PREVIEW_SIZE , pad = False ) stream = io . BytesIO () image . save ( stream , format = \"JPEG\" , quality = 50 ) return stream . getvalue (), \"image/jpeg\" def save ( template : Template , lines : List [ str ], ext : str = settings . DEFAULT_EXT , style : str = settings . DEFAULT_STYLE , size : Dimensions = ( 0 , 0 ), * , directory : Path = settings . IMAGES_DIRECTORY , ) -> Path : size = fit_image ( * size ) slug = encode ( lines ) variant = str ( style ) + str ( size ) fingerprint = hashlib . sha1 ( variant . encode ()) . hexdigest () path = directory / template . key / f \"{slug}.{fingerprint}.{ext}\" if path . exists (): logger . info ( f \"Found meme at {path}\" ) if settings . DEPLOYED : return path else : logger . info ( f \"Saving meme to {path}\" ) path . parent . mkdir ( parents = True , exist_ok = True ) image = render_image ( template , style , lines , size ) image . save ( path , quality = 95 ) return path def load ( path : Path ) -> Image : image = Image . open ( path ) . convert ( \"RGB\" ) image = ImageOps . exif_transpose ( image ) return image def render_image ( template : Template , style : str , lines : List [ str ], size : Dimensions , * , pad : Optional [ bool ] = None , ) -> Image : background = load ( template . get_image ( style )) pad = all ( size ) if pad is None else pad image = resize_image ( background , * size , pad ) for ( point , offset , text , max_text_size , text_fill , font_size , stroke_width , stroke_fill , angle , ) in get_image_elements ( template , lines , image . size ): box = Image . new ( \"RGBA\" , max_text_size ) draw = ImageDraw . Draw ( box ) if settings . DEBUG : xy = ( 0 , 0 , max_text_size [ 0 ] - 1 , max_text_size [ 1 ] - 1 ) draw . rectangle ( xy , outline = \"lime\" ) if angle : font = ImageFont . truetype ( str ( settings . FONT_THIN ), size = font_size ) else : font = ImageFont . truetype ( str ( settings . FONT_THICK ), size = font_size ) draw . text ( ( - offset [ 0 ], - offset [ 1 ]), text , text_fill , font , spacing =- offset [ 1 ] / 2 , align = \"center\" , stroke_width = stroke_width , stroke_fill = stroke_fill , ) box = box . rotate ( angle , resample = Image . BICUBIC , expand = True ) image . paste ( box , point , box ) if pad : image = add_blurred_background ( image , background , * size ) return image def resize_image ( image : Image , width : int , height : int , pad : bool ) -> Image : ratio = image . width / image . height default_width , default_height = settings . DEFAULT_SIZE if pad : if width < height * ratio : size = width , int ( width / ratio ) else : size = int ( height * ratio ), height elif width : size = width , int ( width / ratio ) elif height : size = int ( height * ratio ), height elif ratio < 1.0 : size = default_width , int ( default_height / ratio ) else : size = int ( default_width * ratio ), default_height image = image . resize ( size , Image . LANCZOS ) return image def fit_image ( width : float , height : float ) -> Tuple [ int , int ]: while width * height > settings . MAXIMUM_PIXELS : width *= 0.75 height *= 0.75 return int ( width ), int ( height ) def add_blurred_background ( foreground : Image , background : Image , width : int , height : int ) -> Image : base_width , base_height = foreground . size border_width = min ( width , base_width + 2 ) border_height = min ( height , base_height + 2 ) border_dimensions = border_width , border_height border = Image . new ( \"RGB\" , border_dimensions ) border . paste ( foreground , (( border_width - base_width ) // 2 , ( border_height - base_height ) // 2 ), ) padded = background . resize (( width , height ), Image . LANCZOS ) darkened = padded . point ( lambda p : p * 0.4 ) blurred = darkened . filter ( ImageFilter . GaussianBlur ( 5 )) blurred_width , blurred_height = blurred . size offset = ( ( blurred_width - border_width ) // 2 , ( blurred_height - border_height ) // 2 , ) blurred . paste ( border , offset ) return blurred def get_image_elements ( template : Template , lines : List [ str ], image_size : Dimensions ) -> Iterator [ Tuple [ Point , Offset , str , Dimensions , str , int , int , str , float ]]: for index , text in enumerate ( template . text ): point = text . get_anchor ( image_size ) max_text_size = text . get_size ( image_size ) max_font_size = int ( image_size [ 1 ] / 9 ) try : line = lines [ index ] except IndexError : line = \"\" else : line = text . stylize ( wrap ( line , max_text_size , max_font_size )) font = get_font ( line , text . angle , max_text_size , max_font_size ) offset = get_text_offset ( line , font , max_text_size ) stroke_fill = \"black\" if text . color == \"black\" : stroke_width = 0 else : stroke_width = get_stroke_width ( font ) yield point , offset , line , max_text_size , text . color , font . size , stroke_width , stroke_fill , text . angle def wrap ( line : str , max_text_size : Dimensions , max_font_size : int ) -> str : lines = split ( line ) single = get_font ( line , 0 , max_text_size , max_font_size ) double = get_font ( lines , 0 , max_text_size , max_font_size ) if single . size >= double . size : return line if get_text_size ( lines , double )[ 0 ] >= max_text_size [ 0 ] * 0.65 : return lines return line def split ( line : str ) -> str : midpoint = len ( line ) // 2 - 1 for offset in range ( 0 , len ( line ) // 4 ): for index in [ midpoint - offset , midpoint + offset ]: if line [ index ] == \" \" : return line [: index ] + \" \\n \" + line [ index :] return line def get_font ( text : str , angle : float , max_text_size : Dimensions , max_font_size : int ) -> ImageFont : max_text_width = max_text_size [ 0 ] - max_text_size [ 0 ] / 35 max_text_height = max_text_size [ 1 ] - max_text_size [ 1 ] / 10 for size in range ( max ( 7 , max_font_size ), 6 , - 1 ): if angle : font = ImageFont . truetype ( str ( settings . FONT_THIN ), size = size ) else : font = ImageFont . truetype ( str ( settings . FONT_THICK ), size = size ) text_width , text_height = get_text_size_minus_font_offset ( text , font ) if text_width <= max_text_width and text_height <= max_text_height : break return font def get_text_size_minus_font_offset ( text : str , font : ImageFont ) -> Dimensions : text_width , text_height = get_text_size ( text , font ) offset = font . getoffset ( text ) return text_width - offset [ 0 ], text_height - offset [ 1 ] def get_text_offset ( text : str , font : ImageFont , max_text_size : Dimensions ) -> Offset : text_size = get_text_size ( text , font ) stroke_width = get_stroke_width ( font ) x_offset , y_offset = font . getoffset ( text ) x_offset -= stroke_width y_offset -= stroke_width x_offset -= ( max_text_size [ 0 ] - text_size [ 0 ]) / 2 y_offset -= ( max_text_size [ 1 ] - text_size [ 1 ] / ( 1.25 if \" \\n \" in text else 1.5 )) // 2 return x_offset , y_offset def get_text_size ( text : str , font : ImageFont ) -> Dimensions : image = Image . new ( \"RGB\" , ( 100 , 100 )) draw = ImageDraw . Draw ( image ) text_size = draw . textsize ( text , font ) stroke_width = get_stroke_width ( font ) return text_size [ 0 ] + stroke_width , text_size [ 1 ] + stroke_width def get_stroke_width ( font : ImageFont ) -> int : return min ( 3 , max ( 1 , font . size // 12 )) Variables TYPE_CHECKING Functions add_blurred_background def add_blurred_background ( foreground : 'Image' , background : 'Image' , width : 'int' , height : 'int' ) -> 'Image' View Source def add_blurred_background ( foreground: Image , background: Image , width: int , height: int ) -> Image: base_width , base_height = foreground . size border_width = min ( width , base_width + 2 ) border_height = min ( height , base_height + 2 ) border_dimensions = border_width , border_height border = Image . new ( \"RGB\" , border_dimensions ) border . paste ( foreground , (( border_width - base_width ) // 2, (border_height - base_height) // 2), ) padded = background . resize (( width , height ), Image . LANCZOS ) darkened = padded . point ( lambda p: p * 0.4 ) blurred = darkened . filter ( ImageFilter . GaussianBlur ( 5 )) blurred_width , blurred_height = blurred . size offset = ( ( blurred_width - border_width ) // 2, ( blurred_height - border_height ) // 2, ) blurred . paste ( border , offset ) return blurred fit_image def fit_image ( width : 'float' , height : 'float' ) -> 'Tuple[int, int]' View Source def fit_image ( width : float , height : float ) -> Tuple [ int , int ]: while width * height > settings . MAXIMUM_PIXELS : width *= 0 . 75 height *= 0 . 75 return int ( width ), int ( height ) get_font def get_font ( text : 'str' , angle : 'float' , max_text_size : 'Dimensions' , max_font_size : 'int' ) -> 'ImageFont' View Source def get_font ( text : str , angle : float , max_text_size : Dimensions , max_font_size : int ) -> ImageFont : max_text_width = max_text_size [ 0 ] - max_text_size [ 0 ] / 35 max_text_height = max_text_size [ 1 ] - max_text_size [ 1 ] / 10 for size in range ( max ( 7 , max_font_size ), 6 , - 1 ): if angle : font = ImageFont . truetype ( str ( settings . FONT_THIN ), size = size ) else : font = ImageFont . truetype ( str ( settings . FONT_THICK ), size = size ) text_width , text_height = get_text_size_minus_font_offset ( text , font ) if text_width <= max_text_width and text_height <= max_text_height : break return font get_image_elements def get_image_elements ( template : 'Template' , lines : 'List[str]' , image_size : 'Dimensions' ) -> 'Iterator[Tuple[Point, Offset, str, Dimensions, str, int, int, str, float]]' View Source def get_image_elements ( template : Template , lines : List [ str ] , image_size : Dimensions ) -> Iterator [ Tuple[Point, Offset, str, Dimensions, str, int, int, str, float ] ]: for index , text in enumerate ( template . text ) : point = text . get_anchor ( image_size ) max_text_size = text . get_size ( image_size ) max_font_size = int ( image_size [ 1 ] / 9 ) try : line = lines [ index ] except IndexError : line = \"\" else : line = text . stylize ( wrap ( line , max_text_size , max_font_size )) font = get_font ( line , text . angle , max_text_size , max_font_size ) offset = get_text_offset ( line , font , max_text_size ) stroke_fill = \"black\" if text . color == \"black\" : stroke_width = 0 else : stroke_width = get_stroke_width ( font ) yield point , offset , line , max_text_size , text . color , font . size , stroke_width , stroke_fill , text . angle get_stroke_width def get_stroke_width ( font : 'ImageFont' ) -> 'int' View Source def get_stroke_width ( font : ImageFont ) -> int : return min ( 3 , max ( 1 , font . size // 12 )) get_text_offset def get_text_offset ( text : 'str' , font : 'ImageFont' , max_text_size : 'Dimensions' ) -> 'Offset' View Source def get_text_offset ( text : str , font : ImageFont , max_text_size : Dimensions ) -> Offset : text_size = get_text_size ( text , font ) stroke_width = get_stroke_width ( font ) x_offset , y_offset = font . getoffset ( text ) x_offset -= stroke_width y_offset -= stroke_width x_offset -= ( max_text_size [ 0 ] - text_size [ 0 ]) / 2 y_offset -= ( max_text_size [ 1 ] - text_size [ 1 ] / ( 1 . 25 if \"\\n\" in text else 1 . 5 )) // 2 return x_offset , y_offset get_text_size def get_text_size ( text : 'str' , font : 'ImageFont' ) -> 'Dimensions' View Source def get_text_size ( text : str , font : ImageFont ) -> Dimensions : image = Image . new ( \"RGB\" , ( 100 , 100 )) draw = ImageDraw . Draw ( image ) text_size = draw . textsize ( text , font ) stroke_width = get_stroke_width ( font ) return text_size [ 0 ] + stroke_width , text_size [ 1 ] + stroke_width get_text_size_minus_font_offset def get_text_size_minus_font_offset ( text : 'str' , font : 'ImageFont' ) -> 'Dimensions' View Source def get_text_size_minus_font_offset ( text : str , font : ImageFont ) -> Dimensions : text_width , text_height = get_text_size ( text , font ) offset = font . getoffset ( text ) return text_width - offset [ 0 ], text_height - offset [ 1 ] load def load ( path : 'Path' ) -> 'Image' View Source def load ( path : Path ) -> Image : image = Image . open ( path ) . convert ( \"RGB\" ) image = ImageOps . exif_transpose ( image ) return image preview def preview ( template : 'Template' , lines : 'List[str]' , style : 'str' = 'default' ) -> 'Tuple[bytes, str]' View Source def preview ( template : Template , lines : List [ str ] , style : str = settings . DEFAULT_STYLE ) -> Tuple [ bytes, str ] : image = render_image ( template , style , lines , settings . PREVIEW_SIZE , pad = False ) stream = io . BytesIO () image . save ( stream , format = \"JPEG\" , quality = 50 ) return stream . getvalue (), \"image/jpeg\" render_image def render_image ( template : 'Template' , style : 'str' , lines : 'List[str]' , size : 'Dimensions' , * , pad : 'Optional[bool]' = None ) -> 'Image' View Source def render_image ( template : Template , style : str , lines : List [ str ] , size : Dimensions , * , pad : Optional [ bool ] = None , ) -> Image : background = load ( template . get_image ( style )) pad = all ( size ) if pad is None else pad image = resize_image ( background , * size , pad ) for ( point , offset , text , max_text_size , text_fill , font_size , stroke_width , stroke_fill , angle , ) in get_image_elements ( template , lines , image . size ) : box = Image . new ( \"RGBA\" , max_text_size ) draw = ImageDraw . Draw ( box ) if settings . DEBUG : xy = ( 0 , 0 , max_text_size [ 0 ] - 1 , max_text_size [ 1 ] - 1 ) draw . rectangle ( xy , outline = \"lime\" ) if angle : font = ImageFont . truetype ( str ( settings . FONT_THIN ), size = font_size ) else : font = ImageFont . truetype ( str ( settings . FONT_THICK ), size = font_size ) draw . text ( ( - offset [ 0 ] , - offset [ 1 ] ), text , text_fill , font , spacing =- offset [ 1 ] / 2 , align = \"center\" , stroke_width = stroke_width , stroke_fill = stroke_fill , ) box = box . rotate ( angle , resample = Image . BICUBIC , expand = True ) image . paste ( box , point , box ) if pad : image = add_blurred_background ( image , background , * size ) return image resize_image def resize_image ( image : 'Image' , width : 'int' , height : 'int' , pad : 'bool' ) -> 'Image' View Source def resize_image ( image : Image , width : int , height : int , pad : bool ) -> Image : ratio = image . width / image . height default_width , default_height = settings . DEFAULT_SIZE if pad : if width < height * ratio : size = width , int ( width / ratio ) else : size = int ( height * ratio ), height elif width : size = width , int ( width / ratio ) elif height : size = int ( height * ratio ), height elif ratio < 1 . 0 : size = default_width , int ( default_height / ratio ) else : size = int ( default_width * ratio ), default_height image = image . resize ( size , Image . LANCZOS ) return image save def save ( template : 'Template' , lines : 'List[str]' , ext : 'str' = 'png' , style : 'str' = 'default' , size : 'Dimensions' = ( 0 , 0 ), * , directory : 'Path' = PosixPath ( '/home/kyle/repos/memegen/images' ) ) -> 'Path' View Source def save ( template : Template , lines : List [ str ] , ext : str = settings . DEFAULT_EXT , style : str = settings . DEFAULT_STYLE , size : Dimensions = ( 0 , 0 ), * , directory : Path = settings . IMAGES_DIRECTORY , ) -> Path : size = fit_image ( * size ) slug = encode ( lines ) variant = str ( style ) + str ( size ) fingerprint = hashlib . sha1 ( variant . encode ()). hexdigest () path = directory / template . key / f \"{slug}.{fingerprint}.{ext}\" if path . exists () : logger . info ( f \"Found meme at {path}\" ) if settings . DEPLOYED : return path else : logger . info ( f \"Saving meme to {path}\" ) path . parent . mkdir ( parents = True , exist_ok = True ) image = render_image ( template , style , lines , size ) image . save ( path , quality = 95 ) return path split def split ( line : 'str' ) -> 'str' View Source def split ( line : str ) -> str : midpoint = len ( line ) // 2 - 1 for offset in range ( 0 , len ( line ) // 4 ) : for index in [ midpoint - offset, midpoint + offset ] : if line [ index ] == \" \" : return line [ :index ] + \"\\n\" + line [ index: ] return line wrap def wrap ( line : 'str' , max_text_size : 'Dimensions' , max_font_size : 'int' ) -> 'str' View Source def wrap ( line : str , max_text_size : Dimensions , max_font_size : int ) -> str : lines = split ( line ) single = get_font ( line , 0 , max_text_size , max_font_size ) double = get_font ( lines , 0 , max_text_size , max_font_size ) if single . size >= double . size : return line if get_text_size ( lines , double )[ 0 ] >= max_text_size [ 0 ] * 0 . 65 : return lines return line","title":"Images"},{"location":"reference/app/utils/images/#module-apputilsimages","text":"View Source from __future__ import annotations import hashlib import io from pathlib import Path from typing import TYPE_CHECKING , Iterator , List , Optional , Tuple from PIL import Image , ImageDraw , ImageFilter , ImageFont , ImageOps from sanic.log import logger from .. import settings from ..types import Dimensions , Offset , Point from .text import encode if TYPE_CHECKING : from ..models import Template def preview ( template : Template , lines : List [ str ], style : str = settings . DEFAULT_STYLE ) -> Tuple [ bytes , str ]: image = render_image ( template , style , lines , settings . PREVIEW_SIZE , pad = False ) stream = io . BytesIO () image . save ( stream , format = \"JPEG\" , quality = 50 ) return stream . getvalue (), \"image/jpeg\" def save ( template : Template , lines : List [ str ], ext : str = settings . DEFAULT_EXT , style : str = settings . DEFAULT_STYLE , size : Dimensions = ( 0 , 0 ), * , directory : Path = settings . IMAGES_DIRECTORY , ) -> Path : size = fit_image ( * size ) slug = encode ( lines ) variant = str ( style ) + str ( size ) fingerprint = hashlib . sha1 ( variant . encode ()) . hexdigest () path = directory / template . key / f \"{slug}.{fingerprint}.{ext}\" if path . exists (): logger . info ( f \"Found meme at {path}\" ) if settings . DEPLOYED : return path else : logger . info ( f \"Saving meme to {path}\" ) path . parent . mkdir ( parents = True , exist_ok = True ) image = render_image ( template , style , lines , size ) image . save ( path , quality = 95 ) return path def load ( path : Path ) -> Image : image = Image . open ( path ) . convert ( \"RGB\" ) image = ImageOps . exif_transpose ( image ) return image def render_image ( template : Template , style : str , lines : List [ str ], size : Dimensions , * , pad : Optional [ bool ] = None , ) -> Image : background = load ( template . get_image ( style )) pad = all ( size ) if pad is None else pad image = resize_image ( background , * size , pad ) for ( point , offset , text , max_text_size , text_fill , font_size , stroke_width , stroke_fill , angle , ) in get_image_elements ( template , lines , image . size ): box = Image . new ( \"RGBA\" , max_text_size ) draw = ImageDraw . Draw ( box ) if settings . DEBUG : xy = ( 0 , 0 , max_text_size [ 0 ] - 1 , max_text_size [ 1 ] - 1 ) draw . rectangle ( xy , outline = \"lime\" ) if angle : font = ImageFont . truetype ( str ( settings . FONT_THIN ), size = font_size ) else : font = ImageFont . truetype ( str ( settings . FONT_THICK ), size = font_size ) draw . text ( ( - offset [ 0 ], - offset [ 1 ]), text , text_fill , font , spacing =- offset [ 1 ] / 2 , align = \"center\" , stroke_width = stroke_width , stroke_fill = stroke_fill , ) box = box . rotate ( angle , resample = Image . BICUBIC , expand = True ) image . paste ( box , point , box ) if pad : image = add_blurred_background ( image , background , * size ) return image def resize_image ( image : Image , width : int , height : int , pad : bool ) -> Image : ratio = image . width / image . height default_width , default_height = settings . DEFAULT_SIZE if pad : if width < height * ratio : size = width , int ( width / ratio ) else : size = int ( height * ratio ), height elif width : size = width , int ( width / ratio ) elif height : size = int ( height * ratio ), height elif ratio < 1.0 : size = default_width , int ( default_height / ratio ) else : size = int ( default_width * ratio ), default_height image = image . resize ( size , Image . LANCZOS ) return image def fit_image ( width : float , height : float ) -> Tuple [ int , int ]: while width * height > settings . MAXIMUM_PIXELS : width *= 0.75 height *= 0.75 return int ( width ), int ( height ) def add_blurred_background ( foreground : Image , background : Image , width : int , height : int ) -> Image : base_width , base_height = foreground . size border_width = min ( width , base_width + 2 ) border_height = min ( height , base_height + 2 ) border_dimensions = border_width , border_height border = Image . new ( \"RGB\" , border_dimensions ) border . paste ( foreground , (( border_width - base_width ) // 2 , ( border_height - base_height ) // 2 ), ) padded = background . resize (( width , height ), Image . LANCZOS ) darkened = padded . point ( lambda p : p * 0.4 ) blurred = darkened . filter ( ImageFilter . GaussianBlur ( 5 )) blurred_width , blurred_height = blurred . size offset = ( ( blurred_width - border_width ) // 2 , ( blurred_height - border_height ) // 2 , ) blurred . paste ( border , offset ) return blurred def get_image_elements ( template : Template , lines : List [ str ], image_size : Dimensions ) -> Iterator [ Tuple [ Point , Offset , str , Dimensions , str , int , int , str , float ]]: for index , text in enumerate ( template . text ): point = text . get_anchor ( image_size ) max_text_size = text . get_size ( image_size ) max_font_size = int ( image_size [ 1 ] / 9 ) try : line = lines [ index ] except IndexError : line = \"\" else : line = text . stylize ( wrap ( line , max_text_size , max_font_size )) font = get_font ( line , text . angle , max_text_size , max_font_size ) offset = get_text_offset ( line , font , max_text_size ) stroke_fill = \"black\" if text . color == \"black\" : stroke_width = 0 else : stroke_width = get_stroke_width ( font ) yield point , offset , line , max_text_size , text . color , font . size , stroke_width , stroke_fill , text . angle def wrap ( line : str , max_text_size : Dimensions , max_font_size : int ) -> str : lines = split ( line ) single = get_font ( line , 0 , max_text_size , max_font_size ) double = get_font ( lines , 0 , max_text_size , max_font_size ) if single . size >= double . size : return line if get_text_size ( lines , double )[ 0 ] >= max_text_size [ 0 ] * 0.65 : return lines return line def split ( line : str ) -> str : midpoint = len ( line ) // 2 - 1 for offset in range ( 0 , len ( line ) // 4 ): for index in [ midpoint - offset , midpoint + offset ]: if line [ index ] == \" \" : return line [: index ] + \" \\n \" + line [ index :] return line def get_font ( text : str , angle : float , max_text_size : Dimensions , max_font_size : int ) -> ImageFont : max_text_width = max_text_size [ 0 ] - max_text_size [ 0 ] / 35 max_text_height = max_text_size [ 1 ] - max_text_size [ 1 ] / 10 for size in range ( max ( 7 , max_font_size ), 6 , - 1 ): if angle : font = ImageFont . truetype ( str ( settings . FONT_THIN ), size = size ) else : font = ImageFont . truetype ( str ( settings . FONT_THICK ), size = size ) text_width , text_height = get_text_size_minus_font_offset ( text , font ) if text_width <= max_text_width and text_height <= max_text_height : break return font def get_text_size_minus_font_offset ( text : str , font : ImageFont ) -> Dimensions : text_width , text_height = get_text_size ( text , font ) offset = font . getoffset ( text ) return text_width - offset [ 0 ], text_height - offset [ 1 ] def get_text_offset ( text : str , font : ImageFont , max_text_size : Dimensions ) -> Offset : text_size = get_text_size ( text , font ) stroke_width = get_stroke_width ( font ) x_offset , y_offset = font . getoffset ( text ) x_offset -= stroke_width y_offset -= stroke_width x_offset -= ( max_text_size [ 0 ] - text_size [ 0 ]) / 2 y_offset -= ( max_text_size [ 1 ] - text_size [ 1 ] / ( 1.25 if \" \\n \" in text else 1.5 )) // 2 return x_offset , y_offset def get_text_size ( text : str , font : ImageFont ) -> Dimensions : image = Image . new ( \"RGB\" , ( 100 , 100 )) draw = ImageDraw . Draw ( image ) text_size = draw . textsize ( text , font ) stroke_width = get_stroke_width ( font ) return text_size [ 0 ] + stroke_width , text_size [ 1 ] + stroke_width def get_stroke_width ( font : ImageFont ) -> int : return min ( 3 , max ( 1 , font . size // 12 ))","title":"Module app.utils.images"},{"location":"reference/app/utils/images/#variables","text":"TYPE_CHECKING","title":"Variables"},{"location":"reference/app/utils/images/#functions","text":"","title":"Functions"},{"location":"reference/app/utils/images/#add_blurred_background","text":"def add_blurred_background ( foreground : 'Image' , background : 'Image' , width : 'int' , height : 'int' ) -> 'Image' View Source def add_blurred_background ( foreground: Image , background: Image , width: int , height: int ) -> Image: base_width , base_height = foreground . size border_width = min ( width , base_width + 2 ) border_height = min ( height , base_height + 2 ) border_dimensions = border_width , border_height border = Image . new ( \"RGB\" , border_dimensions ) border . paste ( foreground , (( border_width - base_width ) // 2, (border_height - base_height) // 2), ) padded = background . resize (( width , height ), Image . LANCZOS ) darkened = padded . point ( lambda p: p * 0.4 ) blurred = darkened . filter ( ImageFilter . GaussianBlur ( 5 )) blurred_width , blurred_height = blurred . size offset = ( ( blurred_width - border_width ) // 2, ( blurred_height - border_height ) // 2, ) blurred . paste ( border , offset ) return blurred","title":"add_blurred_background"},{"location":"reference/app/utils/images/#fit_image","text":"def fit_image ( width : 'float' , height : 'float' ) -> 'Tuple[int, int]' View Source def fit_image ( width : float , height : float ) -> Tuple [ int , int ]: while width * height > settings . MAXIMUM_PIXELS : width *= 0 . 75 height *= 0 . 75 return int ( width ), int ( height )","title":"fit_image"},{"location":"reference/app/utils/images/#get_font","text":"def get_font ( text : 'str' , angle : 'float' , max_text_size : 'Dimensions' , max_font_size : 'int' ) -> 'ImageFont' View Source def get_font ( text : str , angle : float , max_text_size : Dimensions , max_font_size : int ) -> ImageFont : max_text_width = max_text_size [ 0 ] - max_text_size [ 0 ] / 35 max_text_height = max_text_size [ 1 ] - max_text_size [ 1 ] / 10 for size in range ( max ( 7 , max_font_size ), 6 , - 1 ): if angle : font = ImageFont . truetype ( str ( settings . FONT_THIN ), size = size ) else : font = ImageFont . truetype ( str ( settings . FONT_THICK ), size = size ) text_width , text_height = get_text_size_minus_font_offset ( text , font ) if text_width <= max_text_width and text_height <= max_text_height : break return font","title":"get_font"},{"location":"reference/app/utils/images/#get_image_elements","text":"def get_image_elements ( template : 'Template' , lines : 'List[str]' , image_size : 'Dimensions' ) -> 'Iterator[Tuple[Point, Offset, str, Dimensions, str, int, int, str, float]]' View Source def get_image_elements ( template : Template , lines : List [ str ] , image_size : Dimensions ) -> Iterator [ Tuple[Point, Offset, str, Dimensions, str, int, int, str, float ] ]: for index , text in enumerate ( template . text ) : point = text . get_anchor ( image_size ) max_text_size = text . get_size ( image_size ) max_font_size = int ( image_size [ 1 ] / 9 ) try : line = lines [ index ] except IndexError : line = \"\" else : line = text . stylize ( wrap ( line , max_text_size , max_font_size )) font = get_font ( line , text . angle , max_text_size , max_font_size ) offset = get_text_offset ( line , font , max_text_size ) stroke_fill = \"black\" if text . color == \"black\" : stroke_width = 0 else : stroke_width = get_stroke_width ( font ) yield point , offset , line , max_text_size , text . color , font . size , stroke_width , stroke_fill , text . angle","title":"get_image_elements"},{"location":"reference/app/utils/images/#get_stroke_width","text":"def get_stroke_width ( font : 'ImageFont' ) -> 'int' View Source def get_stroke_width ( font : ImageFont ) -> int : return min ( 3 , max ( 1 , font . size // 12 ))","title":"get_stroke_width"},{"location":"reference/app/utils/images/#get_text_offset","text":"def get_text_offset ( text : 'str' , font : 'ImageFont' , max_text_size : 'Dimensions' ) -> 'Offset' View Source def get_text_offset ( text : str , font : ImageFont , max_text_size : Dimensions ) -> Offset : text_size = get_text_size ( text , font ) stroke_width = get_stroke_width ( font ) x_offset , y_offset = font . getoffset ( text ) x_offset -= stroke_width y_offset -= stroke_width x_offset -= ( max_text_size [ 0 ] - text_size [ 0 ]) / 2 y_offset -= ( max_text_size [ 1 ] - text_size [ 1 ] / ( 1 . 25 if \"\\n\" in text else 1 . 5 )) // 2 return x_offset , y_offset","title":"get_text_offset"},{"location":"reference/app/utils/images/#get_text_size","text":"def get_text_size ( text : 'str' , font : 'ImageFont' ) -> 'Dimensions' View Source def get_text_size ( text : str , font : ImageFont ) -> Dimensions : image = Image . new ( \"RGB\" , ( 100 , 100 )) draw = ImageDraw . Draw ( image ) text_size = draw . textsize ( text , font ) stroke_width = get_stroke_width ( font ) return text_size [ 0 ] + stroke_width , text_size [ 1 ] + stroke_width","title":"get_text_size"},{"location":"reference/app/utils/images/#get_text_size_minus_font_offset","text":"def get_text_size_minus_font_offset ( text : 'str' , font : 'ImageFont' ) -> 'Dimensions' View Source def get_text_size_minus_font_offset ( text : str , font : ImageFont ) -> Dimensions : text_width , text_height = get_text_size ( text , font ) offset = font . getoffset ( text ) return text_width - offset [ 0 ], text_height - offset [ 1 ]","title":"get_text_size_minus_font_offset"},{"location":"reference/app/utils/images/#load","text":"def load ( path : 'Path' ) -> 'Image' View Source def load ( path : Path ) -> Image : image = Image . open ( path ) . convert ( \"RGB\" ) image = ImageOps . exif_transpose ( image ) return image","title":"load"},{"location":"reference/app/utils/images/#preview","text":"def preview ( template : 'Template' , lines : 'List[str]' , style : 'str' = 'default' ) -> 'Tuple[bytes, str]' View Source def preview ( template : Template , lines : List [ str ] , style : str = settings . DEFAULT_STYLE ) -> Tuple [ bytes, str ] : image = render_image ( template , style , lines , settings . PREVIEW_SIZE , pad = False ) stream = io . BytesIO () image . save ( stream , format = \"JPEG\" , quality = 50 ) return stream . getvalue (), \"image/jpeg\"","title":"preview"},{"location":"reference/app/utils/images/#render_image","text":"def render_image ( template : 'Template' , style : 'str' , lines : 'List[str]' , size : 'Dimensions' , * , pad : 'Optional[bool]' = None ) -> 'Image' View Source def render_image ( template : Template , style : str , lines : List [ str ] , size : Dimensions , * , pad : Optional [ bool ] = None , ) -> Image : background = load ( template . get_image ( style )) pad = all ( size ) if pad is None else pad image = resize_image ( background , * size , pad ) for ( point , offset , text , max_text_size , text_fill , font_size , stroke_width , stroke_fill , angle , ) in get_image_elements ( template , lines , image . size ) : box = Image . new ( \"RGBA\" , max_text_size ) draw = ImageDraw . Draw ( box ) if settings . DEBUG : xy = ( 0 , 0 , max_text_size [ 0 ] - 1 , max_text_size [ 1 ] - 1 ) draw . rectangle ( xy , outline = \"lime\" ) if angle : font = ImageFont . truetype ( str ( settings . FONT_THIN ), size = font_size ) else : font = ImageFont . truetype ( str ( settings . FONT_THICK ), size = font_size ) draw . text ( ( - offset [ 0 ] , - offset [ 1 ] ), text , text_fill , font , spacing =- offset [ 1 ] / 2 , align = \"center\" , stroke_width = stroke_width , stroke_fill = stroke_fill , ) box = box . rotate ( angle , resample = Image . BICUBIC , expand = True ) image . paste ( box , point , box ) if pad : image = add_blurred_background ( image , background , * size ) return image","title":"render_image"},{"location":"reference/app/utils/images/#resize_image","text":"def resize_image ( image : 'Image' , width : 'int' , height : 'int' , pad : 'bool' ) -> 'Image' View Source def resize_image ( image : Image , width : int , height : int , pad : bool ) -> Image : ratio = image . width / image . height default_width , default_height = settings . DEFAULT_SIZE if pad : if width < height * ratio : size = width , int ( width / ratio ) else : size = int ( height * ratio ), height elif width : size = width , int ( width / ratio ) elif height : size = int ( height * ratio ), height elif ratio < 1 . 0 : size = default_width , int ( default_height / ratio ) else : size = int ( default_width * ratio ), default_height image = image . resize ( size , Image . LANCZOS ) return image","title":"resize_image"},{"location":"reference/app/utils/images/#save","text":"def save ( template : 'Template' , lines : 'List[str]' , ext : 'str' = 'png' , style : 'str' = 'default' , size : 'Dimensions' = ( 0 , 0 ), * , directory : 'Path' = PosixPath ( '/home/kyle/repos/memegen/images' ) ) -> 'Path' View Source def save ( template : Template , lines : List [ str ] , ext : str = settings . DEFAULT_EXT , style : str = settings . DEFAULT_STYLE , size : Dimensions = ( 0 , 0 ), * , directory : Path = settings . IMAGES_DIRECTORY , ) -> Path : size = fit_image ( * size ) slug = encode ( lines ) variant = str ( style ) + str ( size ) fingerprint = hashlib . sha1 ( variant . encode ()). hexdigest () path = directory / template . key / f \"{slug}.{fingerprint}.{ext}\" if path . exists () : logger . info ( f \"Found meme at {path}\" ) if settings . DEPLOYED : return path else : logger . info ( f \"Saving meme to {path}\" ) path . parent . mkdir ( parents = True , exist_ok = True ) image = render_image ( template , style , lines , size ) image . save ( path , quality = 95 ) return path","title":"save"},{"location":"reference/app/utils/images/#split","text":"def split ( line : 'str' ) -> 'str' View Source def split ( line : str ) -> str : midpoint = len ( line ) // 2 - 1 for offset in range ( 0 , len ( line ) // 4 ) : for index in [ midpoint - offset, midpoint + offset ] : if line [ index ] == \" \" : return line [ :index ] + \"\\n\" + line [ index: ] return line","title":"split"},{"location":"reference/app/utils/images/#wrap","text":"def wrap ( line : 'str' , max_text_size : 'Dimensions' , max_font_size : 'int' ) -> 'str' View Source def wrap ( line : str , max_text_size : Dimensions , max_font_size : int ) -> str : lines = split ( line ) single = get_font ( line , 0 , max_text_size , max_font_size ) double = get_font ( lines , 0 , max_text_size , max_font_size ) if single . size >= double . size : return line if get_text_size ( lines , double )[ 0 ] >= max_text_size [ 0 ] * 0 . 65 : return lines return line","title":"wrap"},{"location":"reference/app/utils/text/","text":"Module app.utils.text View Source from typing import List , Tuple def encode ( lines : List [ str ]) -> str : encoded_lines = [] for line in lines : if line : encoded = line for before , after in [ ( \"_\" , \"__\" ), ( \"-\" , \"--\" ), ( \" \" , \"_\" ), ( \"?\" , \"~q\" ), ( \"%\" , \"~p\" ), ( \"#\" , \"~h\" ), ( '\"' , \"''\" ), ( \"/\" , \"~s\" ), ( \" \\\\ \" , \"~b\" ), ( \" \\n \" , \"~n\" ), ( \"&\" , \"~a\" ), ]: encoded = encoded . replace ( before , after ) encoded_lines . append ( encoded ) else : encoded_lines . append ( \"_\" ) slug = \"/\" . join ( encoded_lines ) return slug or \"_\" def decode ( slug : str ) -> List [ str ]: has_arrow = \"_-->\" in slug slug = slug . replace ( \"_\" , \" \" ) . replace ( \" \" , \"_\" ) slug = slug . replace ( \"-\" , \" \" ) . replace ( \" \" , \"-\" ) slug = slug . replace ( \"''\" , '\"' ) if has_arrow : slug = slug . replace ( \"- >\" , \" ->\" ) for before , after in [ ( \"~q\" , \"?\" ), ( \"~p\" , \"%\" ), ( \"~h\" , \"#\" ), ( \"~n\" , \" \\n \" ), ( \"~a\" , \"&\" ), ( \"~b\" , \" \\\\ \" ), ]: slug = slug . replace ( before , after ) lines = slug . split ( \"/\" ) lines = [ line . replace ( \"~s\" , \"/\" ) for line in lines ] return lines def normalize ( slug : str ) -> Tuple [ str , bool ]: normalized_slug = encode ( decode ( slug )) return normalized_slug , slug != normalized_slug Functions decode def decode ( slug : str ) -> List [ str ] View Source def decode ( slug : str ) -> List [ str ] : has_arrow = \"_-->\" in slug slug = slug . replace ( \"_\" , \" \" ). replace ( \" \" , \"_\" ) slug = slug . replace ( \"-\" , \" \" ). replace ( \" \" , \"-\" ) slug = slug . replace ( \"''\" , '\"' ) if has_arrow : slug = slug . replace ( \"- >\" , \" ->\" ) for before , after in [ (\"~q\", \"?\"), (\"~p\", \"%\"), (\"~h\", \"#\"), (\"~n\", \"\\n\"), (\"~a\", \"&\"), (\"~b\", \"\\\\\"), ] : slug = slug . replace ( before , after ) lines = slug . split ( \"/\" ) lines = [ line.replace(\"~s\", \"/\") for line in lines ] return lines encode def encode ( lines : List [ str ] ) -> str View Source def encode ( lines : List [ str ] ) -> str : encoded_lines = [] for line in lines : if line : encoded = line for before , after in [ (\"_\", \"__\"), (\"-\", \"--\"), (\" \", \"_\"), (\"?\", \"~q\"), (\"%\", \"~p\"), (\"#\", \"~h\"), ('\"', \"''\"), (\"/\", \"~s\"), (\"\\\\\", \"~b\"), (\"\\n\", \"~n\"), (\"&\", \"~a\"), ] : encoded = encoded . replace ( before , after ) encoded_lines . append ( encoded ) else : encoded_lines . append ( \"_\" ) slug = \"/\" . join ( encoded_lines ) return slug or \"_\" normalize def normalize ( slug : str ) -> Tuple [ str , bool ] View Source def normalize ( slug : str ) -> Tuple [ str , bool ]: normalized_slug = encode ( decode ( slug )) return normalized_slug , slug != normalized_slug","title":"Text"},{"location":"reference/app/utils/text/#module-apputilstext","text":"View Source from typing import List , Tuple def encode ( lines : List [ str ]) -> str : encoded_lines = [] for line in lines : if line : encoded = line for before , after in [ ( \"_\" , \"__\" ), ( \"-\" , \"--\" ), ( \" \" , \"_\" ), ( \"?\" , \"~q\" ), ( \"%\" , \"~p\" ), ( \"#\" , \"~h\" ), ( '\"' , \"''\" ), ( \"/\" , \"~s\" ), ( \" \\\\ \" , \"~b\" ), ( \" \\n \" , \"~n\" ), ( \"&\" , \"~a\" ), ]: encoded = encoded . replace ( before , after ) encoded_lines . append ( encoded ) else : encoded_lines . append ( \"_\" ) slug = \"/\" . join ( encoded_lines ) return slug or \"_\" def decode ( slug : str ) -> List [ str ]: has_arrow = \"_-->\" in slug slug = slug . replace ( \"_\" , \" \" ) . replace ( \" \" , \"_\" ) slug = slug . replace ( \"-\" , \" \" ) . replace ( \" \" , \"-\" ) slug = slug . replace ( \"''\" , '\"' ) if has_arrow : slug = slug . replace ( \"- >\" , \" ->\" ) for before , after in [ ( \"~q\" , \"?\" ), ( \"~p\" , \"%\" ), ( \"~h\" , \"#\" ), ( \"~n\" , \" \\n \" ), ( \"~a\" , \"&\" ), ( \"~b\" , \" \\\\ \" ), ]: slug = slug . replace ( before , after ) lines = slug . split ( \"/\" ) lines = [ line . replace ( \"~s\" , \"/\" ) for line in lines ] return lines def normalize ( slug : str ) -> Tuple [ str , bool ]: normalized_slug = encode ( decode ( slug )) return normalized_slug , slug != normalized_slug","title":"Module app.utils.text"},{"location":"reference/app/utils/text/#functions","text":"","title":"Functions"},{"location":"reference/app/utils/text/#decode","text":"def decode ( slug : str ) -> List [ str ] View Source def decode ( slug : str ) -> List [ str ] : has_arrow = \"_-->\" in slug slug = slug . replace ( \"_\" , \" \" ). replace ( \" \" , \"_\" ) slug = slug . replace ( \"-\" , \" \" ). replace ( \" \" , \"-\" ) slug = slug . replace ( \"''\" , '\"' ) if has_arrow : slug = slug . replace ( \"- >\" , \" ->\" ) for before , after in [ (\"~q\", \"?\"), (\"~p\", \"%\"), (\"~h\", \"#\"), (\"~n\", \"\\n\"), (\"~a\", \"&\"), (\"~b\", \"\\\\\"), ] : slug = slug . replace ( before , after ) lines = slug . split ( \"/\" ) lines = [ line.replace(\"~s\", \"/\") for line in lines ] return lines","title":"decode"},{"location":"reference/app/utils/text/#encode","text":"def encode ( lines : List [ str ] ) -> str View Source def encode ( lines : List [ str ] ) -> str : encoded_lines = [] for line in lines : if line : encoded = line for before , after in [ (\"_\", \"__\"), (\"-\", \"--\"), (\" \", \"_\"), (\"?\", \"~q\"), (\"%\", \"~p\"), (\"#\", \"~h\"), ('\"', \"''\"), (\"/\", \"~s\"), (\"\\\\\", \"~b\"), (\"\\n\", \"~n\"), (\"&\", \"~a\"), ] : encoded = encoded . replace ( before , after ) encoded_lines . append ( encoded ) else : encoded_lines . append ( \"_\" ) slug = \"/\" . join ( encoded_lines ) return slug or \"_\"","title":"encode"},{"location":"reference/app/utils/text/#normalize","text":"def normalize ( slug : str ) -> Tuple [ str , bool ] View Source def normalize ( slug : str ) -> Tuple [ str , bool ]: normalized_slug = encode ( decode ( slug )) return normalized_slug , slug != normalized_slug","title":"normalize"}]}